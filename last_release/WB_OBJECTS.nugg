<?xml version="1.0" encoding="utf-8"?>
<nugget name="Z_ABAP101_EXERCISES">
 <CLAS CLSNAME="ZCX_WB_REPORT_WITHOUT_INTER" VERSION="1" LANGU="E" DESCRIPT="Report/Include without interfaces" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_WB_REPORT_WITHOUT_INTER" REFCLSNAME="ZCX_WB_OBJECTS" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_WB_REPORT_WITHOUT_CLASS" VERSION="1" LANGU="E" DESCRIPT="Report/Include without classes" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_WB_REPORT_WITHOUT_CLASS" REFCLSNAME="ZCX_WB_OBJECTS" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_WB_REPORT_DONT_EXIST" VERSION="1" LANGU="E" DESCRIPT="Report/Include doesn&apos;t exist" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_WB_REPORT_DONT_EXIST" REFCLSNAME="ZCX_WB_OBJECTS" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_WB_OBJECT_DONT_EXIST" VERSION="1" LANGU="E" DESCRIPT="WB object don&apos;t exist" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_WB_OBJECT_DONT_EXIST" REFCLSNAME="ZCX_WB_OBJECTS" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_WB_OBJECTS" VERSION="1" LANGU="E" DESCRIPT="WB Objects generic exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="CX_STATIC_CHECK">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_WB_OBJECTS" REFCLSNAME="CX_STATIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_WB_IS_INTERFACE" VERSION="1" LANGU="E" DESCRIPT="Objects is not a class but an interface" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_WB_IS_INTERFACE" REFCLSNAME="ZCX_WB_OBJECTS" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_WB_IS_CLASS" VERSION="1" LANGU="E" DESCRIPT="Objects is not an interface but a class" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_WB_IS_CLASS" REFCLSNAME="ZCX_WB_OBJECTS" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_WB_INTERFACE_IS_MODEL_ONLY" VERSION="1" LANGU="E" DESCRIPT="Interface is model only" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_WB_INTERFACE_IS_MODEL_ONLY" REFCLSNAME="ZCX_WB_OBJECTS" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_WB_INTERFACE_DONT_EXIST" VERSION="1" LANGU="E" DESCRIPT="Interface do not exist" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_WB_INTERFACE_DONT_EXIST" REFCLSNAME="ZCX_WB_OBJECTS" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_WB_CLASS_IS_MODEL_ONLY" VERSION="1" LANGU="E" DESCRIPT="Class is model only" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_WB_CLASS_IS_MODEL_ONLY" REFCLSNAME="ZCX_WB_OBJECTS" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_WB_CLASS_DONT_EXIST" VERSION="1" LANGU="E" DESCRIPT="Class do not exist" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_WB_CLASS_DONT_EXIST" REFCLSNAME="ZCX_WB_OBJECTS" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_VIEW" VERSION="1" LANGU="E" DESCRIPT="Database View" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <types CLSNAME="ZCL_WB_VIEW" CMPNAME="TY_TT_DD26V" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="12 " SRCCOLUMN1="9 " SRCROW2="12 " SRCCOLUMN2="48 " TYPESRC_LENG="42 " TYPESRC="TY_TT_DD26V TYPE STANDARD TABLE OF DD26V
"/>
  <types CLSNAME="ZCL_WB_VIEW" CMPNAME="TY_TT_DD27P" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="9 " SRCROW2="13 " SRCCOLUMN2="48 " TYPESRC_LENG="42 " TYPESRC="TY_TT_DD27P TYPE STANDARD TABLE OF DD27P
"/>
  <types CLSNAME="ZCL_WB_VIEW" CMPNAME="TY_TT_DD28J" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="14 " SRCCOLUMN1="9 " SRCROW2="14 " SRCCOLUMN2="48 " TYPESRC_LENG="42 " TYPESRC="TY_TT_DD28J TYPE STANDARD TABLE OF DD28J
"/>
  <types CLSNAME="ZCL_WB_VIEW" CMPNAME="TY_TT_DD28V" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="15 " SRCCOLUMN1="9 " SRCROW2="15 " SRCCOLUMN2="48 " TYPESRC_LENG="42 " TYPESRC="TY_TT_DD28V TYPE STANDARD TABLE OF DD28V
"/>
  <implementing CLSNAME="ZCL_WB_VIEW" REFCLSNAME="ZIF_WB_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>*&quot;* use this source file for your ABAP unit test classes</localTestClasses>
  <attribute CLSNAME="ZCL_WB_VIEW" CMPNAME="DD09L_WA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DD09V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_VIEW" CMPNAME="DD25V_WA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DD25V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_VIEW" CMPNAME="DD26V_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD26V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_VIEW" CMPNAME="DD27P_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD27P" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_VIEW" CMPNAME="DD28J_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="9 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD28J" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_VIEW" CMPNAME="DD28V_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="10 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD28V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_VIEW" CMPNAME="GOTSTATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDGOTSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_VIEW" CMPNAME="LANGU" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SY-LANGU" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_VIEW" CMPNAME="NAME" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_VIEW" CMPNAME="STATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_WB_VIEW" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.

call function &apos;DDIF_VIEW_GET&apos;
  EXPORTING
    name          = me-&gt;name    &quot; Name of the view to be read
    state         = me-&gt;state    &quot; Read status of the view
    langu         = me-&gt;langu    &quot; Language in which Texts are Read
  IMPORTING
    gotstate      = me-&gt;gotstate    &quot; Status in which Reading took Place
    dd25v_wa      = me-&gt;dd25v_wa    &quot; View header
    dd09l_wa      = me-&gt;dd09l_wa    &quot; Technical settings of the view
  TABLES
    dd26v_tab     = me-&gt;dd26v_tab    &quot; Basis tables of the view
    dd27p_tab     = me-&gt;dd27p_tab    &quot; View fields
    dd28j_tab     = me-&gt;dd28j_tab    &quot; Join conditions of the view
    dd28v_tab     = me-&gt;dd28v_tab    &quot; Selection conditions of the view
  EXCEPTIONS
    illegal_input = 1
    others        = 2
  .

    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE zcx_wb_object_dont_exist.
    ENDIF.

  ENDMETHOD.                    &quot;zif_wb_object~LOAD</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_VIEW" CPDNAME="ZIF_WB_OBJECT~TO_STRING">
   <source>METHOD zif_wb_object~to_string.

    CONCATENATE:
             &apos;View:&apos;
             me-&gt;name
             &apos;-&apos;
             me-&gt;dd25v_wa-ddtext
         INTO re_string
         SEPARATED BY &apos; &apos;.

  ENDMETHOD.                    &quot;zif_wb_object~to_string</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_VIEW" CPDNAME="ZIF_WB_OBJECT~WRITE">
   <source>METHOD zif_wb_object~write.

  ENDMETHOD.                    &quot;zif_wb_object~write</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_VIEW" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_VIEW" CMPNAME="CONSTRUCTOR" SCONAME="IM_NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJNAME"/>
   <parameter CLSNAME="ZCL_WB_VIEW" CMPNAME="CONSTRUCTOR" SCONAME="IM_STATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJSTATE" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_WB_VIEW" CMPNAME="CONSTRUCTOR" SCONAME="IM_LANGU" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYST-LANGU" PAROPTIONL="X"/>
   <source>METHOD constructor.
    me-&gt;name = im_name.

    me-&gt;state = im_state.
    IF im_state IS NOT SUPPLIED.
      me-&gt;state = &apos;A&apos;.
    ENDIF.

    me-&gt;langu = im_langu.
    IF im_langu IS NOT SUPPLIED.
      me-&gt;langu = space.
    ENDIF.

  ENDMETHOD.                    &quot;constructor</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_TABLE_TYPE" VERSION="1" LANGU="E" DESCRIPT="Table Type" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <types CLSNAME="ZCL_WB_TABLE_TYPE" CMPNAME="TY_TT_DD42V" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="11 " SRCROW2="13 " SRCCOLUMN2="50 " TYPESRC_LENG="42 " TYPESRC="ty_tt_dd42v TYPE STANDARD TABLE OF dd42v
"/>
  <types CLSNAME="ZCL_WB_TABLE_TYPE" CMPNAME="TY_TT_DD43V" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="14 " SRCCOLUMN1="11 " SRCROW2="14 " SRCCOLUMN2="51 " TYPESRC_LENG="43 " TYPESRC="ty_tt_dd43v TYPE STANDARD TABLE OF zdd43v
"/>
  <implementing CLSNAME="ZCL_WB_TABLE_TYPE" REFCLSNAME="ZIF_WB_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>*&quot;* use this source file for your ABAP unit test classes</localTestClasses>
  <attribute CLSNAME="ZCL_WB_TABLE_TYPE" CMPNAME="DD40V_WA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DD40V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE_TYPE" CMPNAME="DD42V_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD42V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE_TYPE" CMPNAME="DD43V_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD43V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE_TYPE" CMPNAME="GOTSTATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDGOTSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE_TYPE" CMPNAME="LANGU" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SY-LANGU" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE_TYPE" CMPNAME="NAME" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE_TYPE" CMPNAME="STATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_WB_TABLE_TYPE" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.

    CALL FUNCTION &apos;DDIF_TTYP_GET&apos;
      EXPORTING
        name          = me-&gt;name    &quot; Name of Table Type to be Read
        state         = me-&gt;state    &quot; Read Status of Table Type
        langu         = me-&gt;langu    &quot; Language in which Texts are Read
      IMPORTING
        gotstate      = me-&gt;gotstate    &quot; Status in which Reading took Place
        dd40v_wa      = me-&gt;dd40v_wa    &quot; Header of Table Type
      TABLES
        dd42v_tab     = me-&gt;dd42v_tab    &quot; Key Fields of Table Type
        dd43v_tab     = me-&gt;dd43v_tab    &quot; Structure for DD43L and DD43T
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.

    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE zcx_wb_object_dont_exist.
    ENDIF.

  ENDMETHOD.                    &quot;zif_wb_object~LOAD</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_TABLE_TYPE" CPDNAME="ZIF_WB_OBJECT~TO_STRING">
   <source>METHOD zif_wb_object~to_string.

    CONCATENATE:
             &apos;Table Type:&apos;
             me-&gt;name
             &apos;-&apos;
             me-&gt;dd40v_wa-ddtext
         INTO re_string
         SEPARATED BY &apos; &apos;.

  ENDMETHOD.                    &quot;zif_wb_object~to_string</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_TABLE_TYPE" CPDNAME="ZIF_WB_OBJECT~WRITE">
   <source>METHOD zif_wb_object~write.

  ENDMETHOD.                    &quot;zif_wb_object~write</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_TABLE_TYPE" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_TABLE_TYPE" CMPNAME="CONSTRUCTOR" SCONAME="IM_NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJNAME"/>
   <parameter CLSNAME="ZCL_WB_TABLE_TYPE" CMPNAME="CONSTRUCTOR" SCONAME="IM_STATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJSTATE" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_WB_TABLE_TYPE" CMPNAME="CONSTRUCTOR" SCONAME="IM_LANGU" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYST-LANGU" PAROPTIONL="X"/>
   <source>METHOD constructor.
    me-&gt;name = im_name.

    me-&gt;state = im_state.
    IF im_state IS NOT SUPPLIED.
      me-&gt;state = &apos;A&apos;.
    ENDIF.

    me-&gt;langu = im_langu.
    IF im_langu IS NOT SUPPLIED.
      me-&gt;langu = space.
    ENDIF.

  ENDMETHOD.                    &quot;constructor</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_TABLE_TECH_SETTINGS" VERSION="1" LANGU="E" DESCRIPT="Database table technical settings" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_WB_TABLE_TECH_SETTINGS" REFCLSNAME="ZIF_WB_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>*&quot;* use this source file for your ABAP unit test classes</localTestClasses>
  <attribute CLSNAME="ZCL_WB_TABLE_TECH_SETTINGS" CMPNAME="DD09L_WA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DD09V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE_TECH_SETTINGS" CMPNAME="GOTSTATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDGOTSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE_TECH_SETTINGS" CMPNAME="NAME" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE_TECH_SETTINGS" CMPNAME="STATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_WB_TABLE_TECH_SETTINGS" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.

    CALL FUNCTION &apos;DDIF_TABT_GET&apos;
      EXPORTING
        name          = me-&gt;name     &quot; Name of the Table whose Technical Settings should be Read
        state         = me-&gt;state    &quot; Read Status of the Technical Settings
      IMPORTING
        gotstate      = me-&gt;gotstate     &quot; Status in which Reading took Place
        dd09l_wa      = me-&gt;dd09l_wa     &quot; Sources of the Technical Settings
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.

    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE zcx_wb_object_dont_exist.
    ENDIF.

  ENDMETHOD.                    &quot;zif_wb_object~LOAD</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_TABLE_TECH_SETTINGS" CPDNAME="ZIF_WB_OBJECT~TO_STRING">
   <source>METHOD zif_wb_object~to_string.

 CONCATENATE:
          &apos;Table Tecnhical Settings:&apos;
          me-&gt;name
      INTO re_string
      SEPARATED BY &apos; &apos;.

  ENDMETHOD.                    &quot;zif_wb_object~to_string</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_TABLE_TECH_SETTINGS" CPDNAME="ZIF_WB_OBJECT~WRITE">
   <source>METHOD zif_wb_object~write.

  ENDMETHOD.                    &quot;zif_wb_object~write</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_TABLE_TECH_SETTINGS" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_TABLE_TECH_SETTINGS" CMPNAME="CONSTRUCTOR" SCONAME="IM_NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJNAME"/>
   <parameter CLSNAME="ZCL_WB_TABLE_TECH_SETTINGS" CMPNAME="CONSTRUCTOR" SCONAME="IM_STATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJSTATE" PAROPTIONL="X"/>
   <source>METHOD constructor.
    me-&gt;name = im_name.

    me-&gt;state = im_state.
    IF im_state IS NOT SUPPLIED.
      me-&gt;state = &apos;A&apos;.
    ENDIF.

  ENDMETHOD.                    &quot;constructor</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_TABLE" VERSION="1" LANGU="E" DESCRIPT="Database table (transparent table)" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <types CLSNAME="ZCL_WB_TABLE" CMPNAME="TY_TT_DD03P" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="17 " SRCCOLUMN1="11 " SRCROW2="17 " SRCCOLUMN2="50 " TYPESRC_LENG="42 " TYPESRC="ty_tt_dd03p TYPE STANDARD TABLE OF dd03p
"/>
  <types CLSNAME="ZCL_WB_TABLE" CMPNAME="TY_TT_DD05M" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="18 " SRCCOLUMN1="11 " SRCROW2="18 " SRCCOLUMN2="50 " TYPESRC_LENG="42 " TYPESRC="ty_tt_dd05m TYPE STANDARD TABLE OF dd05m
"/>
  <types CLSNAME="ZCL_WB_TABLE" CMPNAME="TY_TT_DD08V" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="19 " SRCCOLUMN1="11 " SRCROW2="19 " SRCCOLUMN2="50 " TYPESRC_LENG="42 " TYPESRC="ty_tt_dd08v TYPE STANDARD TABLE OF dd08v
"/>
  <types CLSNAME="ZCL_WB_TABLE" CMPNAME="TY_TT_DD12V" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="20 " SRCCOLUMN1="11 " SRCROW2="20 " SRCCOLUMN2="50 " TYPESRC_LENG="42 " TYPESRC="ty_tt_dd12v TYPE STANDARD TABLE OF dd12v
"/>
  <types CLSNAME="ZCL_WB_TABLE" CMPNAME="TY_TT_DD17V" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " TYPTYPE="4" SRCROW1="21 " SRCCOLUMN1="11 " SRCROW2="21 " SRCCOLUMN2="50 " TYPESRC_LENG="42 " TYPESRC="ty_tt_dd17v TYPE STANDARD TABLE OF dd17v
"/>
  <types CLSNAME="ZCL_WB_TABLE" CMPNAME="TY_TT_DD35V" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " TYPTYPE="4" SRCROW1="22 " SRCCOLUMN1="11 " SRCROW2="22 " SRCCOLUMN2="50 " TYPESRC_LENG="42 " TYPESRC="ty_tt_dd35v TYPE STANDARD TABLE OF dd35v
"/>
  <types CLSNAME="ZCL_WB_TABLE" CMPNAME="TY_TT_DD36M" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="7 " TYPTYPE="4" SRCROW1="23 " SRCCOLUMN1="11 " SRCROW2="23 " SRCCOLUMN2="50 " TYPESRC_LENG="42 " TYPESRC="ty_tt_dd36m TYPE STANDARD TABLE OF dd36m
"/>
  <implementing CLSNAME="ZCL_WB_TABLE" REFCLSNAME="ZIF_WB_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>*&quot;* use this source file for your ABAP unit test classes</localTestClasses>
  <attribute CLSNAME="ZCL_WB_TABLE" CMPNAME="DD02V_WA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DD02V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE" CMPNAME="DD03P_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD03P" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE" CMPNAME="DD05M_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD05M" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE" CMPNAME="DD08V_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="9 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD08V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE" CMPNAME="DD09L_WA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DD09V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE" CMPNAME="DD12V_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="10 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD12V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE" CMPNAME="DD17V_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="11 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD17V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE" CMPNAME="DD35V_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="12 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD35V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE" CMPNAME="DD36M_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="13 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD36M" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE" CMPNAME="GOTSTATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDGOTSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE" CMPNAME="LANGU" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SY-LANGU" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE" CMPNAME="NAME" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE" CMPNAME="R_TECHNICAL_SETTINGS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="14 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_WB_TABLE_TECH_SETTINGS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_TABLE" CMPNAME="STATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_WB_TABLE" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.

    CALL FUNCTION &apos;DDIF_TABL_GET&apos;
      EXPORTING
        name          = me-&gt;name    &quot; Name of the Table to be Read
        state         = me-&gt;state    &quot; Read Status of the Table
        langu         = me-&gt;langu    &quot; Language in which Texts are Read
      IMPORTING
        gotstate      = me-&gt;gotstate    &quot; Status in which Reading took Place
        dd02v_wa      = me-&gt;dd02v_wa    &quot; Table Header
        dd09l_wa      = me-&gt;dd09l_wa    &quot; Technical Settings of the Table
      TABLES
        dd03p_tab     = me-&gt;dd03p_tab    &quot; Table Fields
        dd05m_tab     = me-&gt;dd05m_tab    &quot; Foreign Key Fields of the Table
        dd08v_tab     = me-&gt;dd08v_tab    &quot; Foreign Keys of the Table
        dd12v_tab     = me-&gt;dd12v_tab    &quot; Table Indexes
        dd17v_tab     = me-&gt;dd17v_tab    &quot; Index Fields of the Table
        dd35v_tab     = me-&gt;dd35v_tab    &quot; Header of the Search Help Assignments of the Table
        dd36m_tab     = me-&gt;dd36m_tab    &quot; Allocations of the Search Help Assignments of the Table
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE zcx_wb_object_dont_exist.
    ENDIF.

    CREATE OBJECT me-&gt;r_technical_settings
      EXPORTING
        im_name  = me-&gt;name
        im_state = me-&gt;state.

    TRY.
        me-&gt;r_technical_settings-&gt;zif_wb_object~load( ).
      CATCH zcx_wb_objects.    &quot; WB Objects generic exception
        &quot; a table should always have its technical settings defined.
    ENDTRY.

  ENDMETHOD.                    &quot;zif_wb_object~LOAD</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_TABLE" CPDNAME="ZIF_WB_OBJECT~TO_STRING">
   <source>METHOD zif_wb_object~to_string.

    CASE me-&gt;dd02v_wa-tabclass. &quot; Structure
      WHEN &apos;INTTAB&apos;. &quot; Structure
        CONCATENATE:
                 &apos;Structure:&apos;
                 me-&gt;name
                 &apos;-&apos;
                 me-&gt;dd02v_wa-ddtext
             INTO re_string
             SEPARATED BY &apos; &apos;.

      WHEN &apos;APPEND&apos;. &quot; Append structure
        CONCATENATE:
          &apos;Append Structure:&apos;
          me-&gt;name
          &apos;-&apos;
          me-&gt;dd02v_wa-ddtext
        INTO re_string
        SEPARATED BY &apos; &apos;.

      WHEN &apos;TRANSP&apos;. &quot; Transparent table
        CONCATENATE:
                 &apos;Table:&apos;
                 me-&gt;name
                 &apos;-&apos;
                 me-&gt;dd02v_wa-ddtext
             INTO re_string
             SEPARATED BY &apos; &apos;.

      WHEN &apos;CLUSTER&apos;. &quot; Cluster table
        CONCATENATE:
                 &apos;Cluster Table:&apos;
                 me-&gt;name
                 &apos;-&apos;
                 me-&gt;dd02v_wa-ddtext
             INTO re_string
             SEPARATED BY &apos; &apos;.

      WHEN &apos;POOL&apos;. &quot; Pooled table
        CONCATENATE:
                 &apos;Pooled Table:&apos;
                 me-&gt;name
                 &apos;-&apos;
                 me-&gt;dd02v_wa-ddtext
             INTO re_string
             SEPARATED BY &apos; &apos;.



    ENDCASE.

  ENDMETHOD.                    &quot;zif_wb_object~to_string</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_TABLE" CPDNAME="ZIF_WB_OBJECT~WRITE">
   <source>METHOD zif_wb_object~write.

  ENDMETHOD.                    &quot;zif_wb_object~write</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_TABLE" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_TABLE" CMPNAME="CONSTRUCTOR" SCONAME="IM_NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJNAME"/>
   <parameter CLSNAME="ZCL_WB_TABLE" CMPNAME="CONSTRUCTOR" SCONAME="IM_STATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJSTATE" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_WB_TABLE" CMPNAME="CONSTRUCTOR" SCONAME="IM_LANGU" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYST-LANGU" PAROPTIONL="X"/>
   <source>METHOD constructor.
    me-&gt;name = im_name.

    me-&gt;state = im_state.
    IF im_state IS NOT SUPPLIED.
      me-&gt;state = &apos;A&apos;.
    ENDIF.

    me-&gt;langu = im_langu.
    IF im_langu IS NOT SUPPLIED.
      me-&gt;langu = space.
    ENDIF.

  ENDMETHOD.                    &quot;constructor</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_SEARCH_HELP" VERSION="1" LANGU="E" DESCRIPT="Search Help" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <types CLSNAME="ZCL_WB_SEARCH_HELP" CMPNAME="TY_DD30V" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="1" TYPE="DD30V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <types CLSNAME="ZCL_WB_SEARCH_HELP" CMPNAME="TY_TT_DD31V" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="8 " SRCROW2="13 " SRCCOLUMN2="47 " TYPESRC_LENG="42 " TYPESRC="TY_TT_DD31V TYPE STANDARD TABLE OF dd31v
"/>
  <types CLSNAME="ZCL_WB_SEARCH_HELP" CMPNAME="TY_TT_DD32P" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="14 " SRCCOLUMN1="8 " SRCROW2="14 " SRCCOLUMN2="47 " TYPESRC_LENG="42 " TYPESRC="TY_TT_DD32P TYPE STANDARD TABLE OF dd32p
"/>
  <types CLSNAME="ZCL_WB_SEARCH_HELP" CMPNAME="TY_TT_DD33V" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="15 " SRCCOLUMN1="8 " SRCROW2="15 " SRCCOLUMN2="47 " TYPESRC_LENG="42 " TYPESRC="TY_TT_DD33V TYPE STANDARD TABLE OF dd33v
"/>
  <implementing CLSNAME="ZCL_WB_SEARCH_HELP" REFCLSNAME="ZIF_WB_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>*&quot;* use this source file for your ABAP unit test classes</localTestClasses>
  <attribute CLSNAME="ZCL_WB_SEARCH_HELP" CMPNAME="DD30V_WA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_DD30V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_SEARCH_HELP" CMPNAME="DD31V_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD31V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_SEARCH_HELP" CMPNAME="DD32P_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD32P" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_SEARCH_HELP" CMPNAME="DD33V_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD33V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_SEARCH_HELP" CMPNAME="GOTSTATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDGOTSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_SEARCH_HELP" CMPNAME="LANGU" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SY-LANGU" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_SEARCH_HELP" CMPNAME="NAME" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_SEARCH_HELP" CMPNAME="STATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_WB_SEARCH_HELP" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.

    CALL FUNCTION &apos;DDIF_SHLP_GET&apos;
      EXPORTING
        name          = me-&gt;name     &quot; Name of Search Help to be Read
        state         = me-&gt;state    &quot; Read Status of Search Help
        langu         = me-&gt;langu    &quot; Language in which Texts are Read
      IMPORTING
        gotstate      = me-&gt;gotstate    &quot; Status in which Reading took Place
        dd30v_wa      = me-&gt;dd30v_wa    &quot; Header of Search Help
      TABLES
        dd31v_tab     = me-&gt;dd31v_tab    &quot; Inclusions of Search Help
        dd32p_tab     = me-&gt;dd32p_tab    &quot; Fields of Search Help
        dd33v_tab     = me-&gt;dd33v_tab    &quot; Field Assignments of Search Help
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.

    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE zcx_wb_object_dont_exist.
    ENDIF.

  ENDMETHOD.                    &quot;zif_wb_object~LOAD</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_SEARCH_HELP" CPDNAME="ZIF_WB_OBJECT~TO_STRING">
   <source>METHOD zif_wb_object~to_string.

    CONCATENATE:
          &apos;Search Help:&apos;
          me-&gt;name
          &apos;-&apos;
          me-&gt;dd30v_wa-ddtext
      INTO re_string
      SEPARATED BY &apos; &apos;.

  ENDMETHOD.                    &quot;zif_wb_object~to_string</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_SEARCH_HELP" CPDNAME="ZIF_WB_OBJECT~WRITE">
   <source>METHOD zif_wb_object~write.

  ENDMETHOD.                    &quot;zif_wb_object~write</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_SEARCH_HELP" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SEARCH_HELP" CMPNAME="CONSTRUCTOR" SCONAME="IM_NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJNAME"/>
   <parameter CLSNAME="ZCL_WB_SEARCH_HELP" CMPNAME="CONSTRUCTOR" SCONAME="IM_STATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJSTATE" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_WB_SEARCH_HELP" CMPNAME="CONSTRUCTOR" SCONAME="IM_LANGU" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYST-LANGU" PAROPTIONL="X"/>
   <source>METHOD constructor.
    me-&gt;name = im_name.

    me-&gt;state = im_state.
    IF im_state IS NOT SUPPLIED.
      me-&gt;state = &apos;A&apos;.
    ENDIF.

    me-&gt;langu = im_langu.
    IF im_langu IS NOT SUPPLIED.
      me-&gt;langu = space.
    ENDIF.

  ENDMETHOD.                    &quot;constructor</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_SCANNER_OBJECTS" VERSION="1" LANGU="E" DESCRIPT="Copy of include LS_ABAP_OBJECTS_SCANTOP" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <types CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCOPE_REC_TYPE" VERSION="1" LANGU="E" DESCRIPT="SCOPE_REC_TYPE" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="11 " SRCCOLUMN2="26 " TYPESRC_LENG="215 " TYPESRC="BEGIN OF scope_rec_type,
        clsname      TYPE c LENGTH 30,
        superclsname TYPE c LENGTH 30,
        is_interface TYPE c LENGTH  1,
        exposure     TYPE n LENGTH  1,
      END OF scope_rec_type
"/>
  <types CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCOPE_STA_TYPE" VERSION="1" LANGU="E" DESCRIPT="SCOPE_STA_TYPE" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="4 " SRCROW2="13 " SRCCOLUMN2="83 " TYPESRC_LENG="82 " TYPESRC="scope_sta_type TYPE STANDARD TABLE OF scope_rec_type WITH NON-UNIQUE KEY clsname
"/>
  <types CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="ME_PRIV_TYPE" VERSION="1" LANGU="E" DESCRIPT="ME_PRIV_TYPE" EXPOSURE="0" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="15 " SRCCOLUMN1="4 " SRCROW2="39 " SRCCOLUMN2="24 " TYPESRC_LENG="889 " TYPESRC="BEGIN OF me_priv_type,
*       tables for SCAN
        state_tab TYPE saboo_statt,
        token_tab TYPE saboo_tokstx,
        sourc_tab TYPE saboo_sourt,
*       global state
        clsname      TYPE c LENGTH 30,
        superclsname TYPE c LENGTH 30,
        is_interface TYPE c LENGTH  1,
        cmpname      TYPE c LENGTH  61,
        version      TYPE n LENGTH  1,
        langu        TYPE c LENGTH  1,
        exposure     TYPE n LENGTH  1,
        state        TYPE n LENGTH  1,
        mtdtype      TYPE n LENGTH  1,
*       nested scope stack &amp; counter
        nested_sc TYPE i,
        scope_sta TYPE scope_sta_type,
*       nested BEGIN ... END type declaration
        inside_begin_end TYPE i,
        begin_end_col    TYPE i,
        begin_end_row    TYPE i,
*       counter for editor order
        editor_order TYPE i,
      END OF me_priv_type
"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_WB_SCANNER_OBJECTS" TYPEGROUP="SABOO" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_SCANNER_OBJECTS" TYPEGROUP="SEOX" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <forwardDeclaration>SABOO</forwardDeclaration>
  <forwardDeclaration>SEOX</forwardDeclaration>
  <attribute CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="CONST" VERSION="1" LANGU="E" DESCRIPT="CONST" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="4 " SRCROW2="31 " SRCCOLUMN2="19 " TYPESRC_LENG="850 " TYPESRC="BEGIN OF const,
          max_line_size TYPE i VALUE 255,
          BEGIN OF aunit_duration,
            short  TYPE vseoclass-duration_type VALUE 12,
            medium TYPE vseoclass-duration_type VALUE 24,
            long   TYPE vseoclass-duration_type VALUE 36,
          END OF aunit_duration,
          BEGIN OF aunit_risk,
            harmless  TYPE vseoclass-risk_level VALUE 11,
            dangerous TYPE vseoclass-risk_level VALUE 22,
            critical  TYPE vseoclass-risk_level VALUE 33,
          END OF aunit_risk,
          BEGIN OF exposure,
            public    TYPE vseoclass-exposure VALUE 2,
            protected TYPE vseoclass-exposure VALUE 1,
            package   TYPE vseoclass-exposure VALUE 3,
            private   TYPE vseoclass-exposure VALUE 0,
          END OF exposure,
        END OF const
"/>
  <attribute CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="ME_PRIV" VERSION="1" LANGU="E" DESCRIPT="ME_PRIV" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="5" TYPE="ME_PRIV_TYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="CREATE" VERSION="1" LANGU="E" DESCRIPT="CREATE" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="CREATE" SCONAME="RESOLVE_INCLUDES" VERSION="1" LANGU="E" DESCRIPT="RESOLVE_INCLUDES" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="CREATE" SCONAME="SCANNER" VERSION="1" LANGU="E" DESCRIPT="SCANNER" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_WB_SCANNER_OBJECTS"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="CREATE" SCONAME="ERROR_SOURCE" VERSION="1" LANGU="E" DESCRIPT="ERROR_SOURCE" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="SYREPID"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="CREATE" SCONAME="SOURC_TAB" VERSION="1" LANGU="E" DESCRIPT="SOURC_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_SOURT"/>
   <source>method CREATE.

    CLEAR error_source.

    CREATE OBJECT scanner.
    scanner-&gt;reset( ).

*   resolve includes ?
    IF resolve_includes = seox_true. &quot; or &apos;X&apos;
      scanner-&gt;resolve_includes( CHANGING sourc_tab = sourc_tab error_source = error_source ).
    ENDIF.
*   scan to get tokens and statements
    SCAN ABAP-SOURCE sourc_tab TOKENS     INTO scanner-&gt;me_priv-token_tab
                               STATEMENTS INTO scanner-&gt;me_priv-state_tab
                               WITH ANALYSIS.
    IF sy-subrc &lt;&gt; 0.
      CLEAR scanner.
      RETURN.
    ENDIF.

    scanner-&gt;me_priv-sourc_tab = sourc_tab.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ALIAS" VERSION="1" LANGU="E" DESCRIPT="INSERT_ALIAS" EXPOSURE="0" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ALIAS" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ALIAS" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ALIAS" SCONAME="ALIAS_TAB" VERSION="1" LANGU="E" DESCRIPT="ALIAS_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_ALIAT"/>
   <source>method INSERT_ALIAS.
* importing    state_pos type i
*              state_end type i
*              changing alias_tab type saboo_aliat.
    DATA:
      alias_rec    TYPE saboo_alias,
      token_re1    TYPE saboo_tokesx,
      token_re2    TYPE saboo_tokesx,
      token_re3    TYPE saboo_tokesx,
      state_length TYPE i,
      x1            TYPE i.
*   fill record with global data
    alias_rec-clsname    = me_priv-clsname.
    alias_rec-version    = me_priv-version.
    alias_rec-exposure   = me_priv-exposure.
*   set comp type of alias (1-attr ...)
    alias_rec-cmptype    = 9.            &quot; 9 is an invalid
*   length of statement
    state_length = state_end - state_pos + 1.
*   attribute declaration greater than ALIASES X.
    IF state_length = 4.
*     look for type, scan from left side
      CLEAR: token_re1, token_re2, token_re3.
      x1 = state_pos + 1.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      x1 = state_pos + 2.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      x1 = state_pos + 3.
      READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*     look for ALIASES .. FOR ..
      IF token_re2-str = &apos;FOR&apos;.
*       get name
        alias_rec-cmpname = token_re1-str.
*       get I~c
        SPLIT token_re3-str AT &apos;~&apos;
          INTO alias_rec-refclsname alias_rec-refcmpname.
*       write entry to admin table
        APPEND alias_rec TO alias_tab.
      ELSE.
*       syntax error or unsupported feature
*        raise resumable exception type statement_illegal.
      ENDIF.
    ELSE.
*     syntax error or unsupported feature
*      raise resumable exception type statement_illegal.
    ENDIF.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ATTRI" VERSION="1" LANGU="E" DESCRIPT="INSERT_ATTRI" EXPOSURE="0" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ATTRI" SCONAME="ATTDECLTYP" VERSION="1" LANGU="E" DESCRIPT="ATTDECLTYP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="N"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ATTRI" SCONAME="STATE_BEGIN" VERSION="1" LANGU="E" DESCRIPT="STATE_BEGIN" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ATTRI" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ATTRI" SCONAME="ATTRI_TAB" VERSION="1" LANGU="E" DESCRIPT="ATTRI_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_ATTRT"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ATTRI" SCONAME="TYPSR_TAB" VERSION="1" LANGU="E" DESCRIPT="TYPSR_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_TYPST"/>
   <source>method INSERT_ATTRI.
*                  exporting value(attdecltyp) type n
*                            state_begin       type i
*                            state_end         type i
*                  changing  attri_tab         type saboo_attrt
*                            typsr_tab         type saboo_typst.
    DATA:
      attri_rec    TYPE saboo_attri,
      token_re1    TYPE saboo_tokesx,
      token_re2    TYPE saboo_tokesx,
      token_re3    TYPE saboo_tokesx,
      typsr_rec    TYPE saboo_typsr,
      cursor_left  TYPE i,
      cursor_right TYPE i,
      state_lenght TYPE i,
      x1            TYPE i,
      no_match     TYPE c,
      att_name(30) TYPE c,
      fl_size(30)  TYPE c.

* write default data for optional fields
    attri_rec-attvalue   = &apos;&apos;.
    attri_rec-typtype    = 1.
    attri_rec-type       = &apos;C&apos;.
    attri_rec-attdecltyp = attdecltyp.
* fill record with global data
    attri_rec-clsname    = me_priv-clsname.
    attri_rec-version    = me_priv-version.
    attri_rec-langu      = me_priv-langu.
    attri_rec-exposure   = me_priv-exposure.
    attri_rec-state      = me_priv-state.
    attri_rec-editorder  = me_priv-editor_order. ADD 1 TO me_priv-editor_order.
* initialize state length, left and right cursor
    state_lenght = state_end - state_begin + 1.
    cursor_left  = state_begin + 1.
    cursor_right = state_end.
* attribute declaration greater than DATA X.
    IF state_lenght &gt; 2.
*   look for type, scan from left side
      CLEAR: token_re1, token_re2, token_re3.
      x1 = cursor_left + 1.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      x1 = cursor_left + 2.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      x1 = cursor_left + 3.
      READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*   ? DATA x TYPE REF TO a ...
      IF ( state_lenght &gt;= 5 ) AND ( token_re1-str = &apos;TYPE&apos; ) AND
         ( token_re2-str = &apos;REF&apos; ) AND ( token_re3-str = &apos;TO&apos; ).
        x1 = cursor_left + 4.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
        attri_rec-typtype = 3.
        attri_rec-type = token_re1-str.
        cursor_left       = cursor_left + 4.
*   ? DATA x TYPE a ...
      ELSEIF ( state_lenght &gt;= 4 ) AND ( token_re1-str = &apos;TYPE&apos; ).
        attri_rec-typtype = 1.
        attri_rec-type = token_re2-str.
        cursor_left    = cursor_left + 2.
*   ? DATA x LIKE a ...
      ELSEIF ( state_lenght &gt;= 4 ) AND ( token_re1-str = &apos;LIKE&apos; ).
        attri_rec-typtype = 0.
        attri_rec-type = token_re2-str.
        cursor_left    = cursor_left + 2.
*   ? BEGIN OF x | END OF x
      ELSEIF ( state_lenght &gt;= 4 ) AND ( token_re1-str = &apos;OF&apos; ).
        CLEAR token_re1.
        x1 = cursor_left.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
        CASE token_re1-str.
*       flag indis BEGIN ... END declaration
          WHEN &apos;BEGIN&apos;.
*         ? nested BEGIN ... END
            IF me_priv-inside_begin_end &gt; 0.
              me_priv-inside_begin_end = me_priv-inside_begin_end + 1.
            ELSE.
              me_priv-inside_begin_end = 1.
              me_priv-begin_end_row    = token_re1-row.
              me_priv-begin_end_col    = token_re1-col.
            ENDIF.
*       end of BEGIN .. END declaration write attribute and source table
          WHEN &apos;END&apos;.
*         END without BEGIN -&gt; error
            IF me_priv-inside_begin_end = 0.
*              raise resumable exception type statement_illegal.
              RETURN.
            ENDIF.
            me_priv-inside_begin_end = me_priv-inside_begin_end - 1.
*         ? nested BEGIN ... END
            IF me_priv-inside_begin_end &gt; 0.
              RETURN.
            ENDIF.
*         append to source table
            typsr_rec-clsname   = me_priv-clsname.
            typsr_rec-cmpname   = token_re2-str.
            typsr_rec-begin_row = me_priv-begin_end_row.
            typsr_rec-begin_col = me_priv-begin_end_col.
            typsr_rec-end_row   = token_re2-row.
            typsr_rec-end_col   = token_re2-col + strlen( token_re2-str ) - 1.
            APPEND typsr_rec TO typsr_tab.
*         insert source
            me-&gt;source_tab_to_char( EXPORTING typsr_rec = typsr_rec CHANGING char = attri_rec-typesrc ).
*         append to attribute table
            attri_rec-cmpname = token_re2-str.
            attri_rec-typtype = 4.
            attri_rec-type    = space.
            APPEND attri_rec TO attri_tab.
        ENDCASE.
        RETURN.
      ENDIF.
*   ? inside a BGIN of x ... END of x declaration
      IF me_priv-inside_begin_end &gt; 0.
        RETURN.
      ENDIF.
*   look for additions, scan from right side
      WHILE ( cursor_left &lt; cursor_right ) AND
            ( no_match &lt;&gt; &apos;X&apos; ).
        state_lenght = cursor_right - cursor_left.
        CLEAR: token_re1, token_re2, token_re3.
        x1 = cursor_right - 2.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
        x1 = cursor_right - 1.
        READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
        x1 = cursor_right.
        READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*     ? VALUE IS INITIAL
        IF ( state_lenght &gt;= 3 ) AND ( token_re1-str = &apos;VALUE&apos; ) AND
           ( token_re2-str = &apos;IS&apos; ) AND ( token_re3-str = &apos;INITIAL&apos; ).
          cursor_right = cursor_right - 3.
*     ? VALUE x
        ELSEIF ( state_lenght &gt;= 2 ) AND ( token_re2-str = &apos;VALUE&apos; ).
          attri_rec-attvalue = token_re3-str.
          cursor_right = cursor_right - 2.
*     ? READ-ONLY
        ELSEIF token_re3-str = &apos;READ-ONLY&apos;.
          attri_rec-attrdonly = &apos;X&apos;.
          cursor_right = cursor_right - 1.
*     ? BOXED
        ELSEIF token_re3-str = &apos;BOXED&apos;.
          attri_rec-typtype = 5.
          cursor_right = cursor_right - 1.
*     -&gt; no more additions
        ELSE.
          no_match = &apos;X&apos;.
        ENDIF.
      ENDWHILE.
    ELSE.
*   ? inside a BGIN of x ... END of x declaration
      IF me_priv-inside_begin_end &gt; 0.
        RETURN.
      ENDIF.
    ENDIF.
* get the name of attribute
    CLEAR: token_re1, att_name, fl_size.
    x1 = state_begin + 1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
* ? xxx(yyy)
    SPLIT token_re1-str AT &apos;(&apos; INTO att_name fl_size.
    DATA dummy TYPE c LENGTH 1.                             &quot;#EC NEEDED
    SPLIT fl_size AT &apos;)&apos; INTO fl_size dummy.
    attri_rec-cmpname = att_name.
* ? complex type
    IF ( cursor_left &lt; cursor_right ) OR ( fl_size &lt;&gt; &apos;&apos; ).
*   fill and append record to type-source table
      CLEAR: token_re1, token_re2.
      x1 = state_begin + 1.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      x1 = cursor_right.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      typsr_rec-clsname   = me_priv-clsname.
      typsr_rec-cmpname   = att_name.
      typsr_rec-begin_row = token_re1-row.
      typsr_rec-begin_col = token_re1-col.
      typsr_rec-end_row   = token_re2-row.
      typsr_rec-end_col   = token_re2-col + strlen( token_re2-str ) - 1.
      APPEND typsr_rec TO typsr_tab.
*   insert source
      me-&gt;source_tab_to_char( EXPORTING typsr_rec = typsr_rec CHANGING char = attri_rec-typesrc ).
*   update attribut record
      attri_rec-typtype = 4.
      attri_rec-type    = space.
    ENDIF.
    APPEND attri_rec TO attri_tab.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLASS" VERSION="1" LANGU="E" DESCRIPT="INSERT_CLASS" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLASS" SCONAME="STATE_BEGIN" VERSION="1" LANGU="E" DESCRIPT="STATE_BEGIN" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLASS" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLASS" SCONAME="CLASS_TAB" VERSION="1" LANGU="E" DESCRIPT="CLASS_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_CLAST"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLASS" SCONAME="EXTED_TAB" VERSION="1" LANGU="E" DESCRIPT="EXTED_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_EXTET"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLASS" SCONAME="FRNDS_TAB" VERSION="1" LANGU="E" DESCRIPT="FRNDS_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_FRNDT"/>
   <source>method INSERT_CLASS.
*   importing state_begin type i
*             state_end   type i
*   changing  class_tab   type saboo_clast
*             exted_tab   type saboo_extet
*             frnds_tab   type saboo_frndt.
    DATA:
      class_rec    TYPE saboo_class,
      exted_rec    TYPE saboo_exted,
      token_rec    TYPE saboo_tokesx,
      x1            TYPE i,
      y            TYPE i.

*   default values
    class_rec-exposure = 2. &quot;PUBLIC
*   get the name of the class
    x1 = state_begin + 1.
    READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
*   get name of class
    class_rec-clsname  = token_rec-str.
*   jump over DEFINITION
    x1 = x1 + 1.
*   look for additions
    WHILE x1 &lt; state_end.
      x1 = x1 + 1.
      READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
      CASE token_rec-str.
*       look for SHARED MEMORY ENABLED
        WHEN &apos;SHARED&apos;.
          y = state_end - x1.
          IF y &gt; 1.
            x1 = x1 + 1.
            READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
            IF token_rec-str = &apos;MEMORY&apos;.
              x1 = x1 + 1.
              READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
              IF token_rec-str = &apos;ENABLED&apos;.
                class_rec-clssharedmemory = &apos;X&apos;.
              ELSE.
                x1 = x1 - 2.
              ENDIF.
            ELSE.
              x1 = x1 - 1.
            ENDIF.
          ENDIF.
*       look for FOR TESTING
        WHEN &apos;FOR&apos;.
          y = state_end - x1.
*         there are enough tokens
          IF y &gt; 0.
            x1 = x1 + 1.
            READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
            IF token_rec-str = &apos;TESTING&apos;.
              class_rec-with_unit_tests = abap_true.
            ENDIF.
          ENDIF.
*       look for DURATION SHORT/MEDIUM/LONG
        WHEN &apos;DURATION&apos;.
          y = state_end - x1.
*       there are enough tokens
          IF y &gt; 0.
            x1 = x1 + 1.
            READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
            CASE token_rec-str.
              WHEN &apos;SHORT&apos;.
                class_rec-duration_type = const-aunit_duration-short.
              WHEN &apos;MEDIUM&apos;.
                class_rec-duration_type = const-aunit_duration-medium.
              WHEN &apos;LONG&apos;.
                class_rec-duration_type = const-aunit_duration-long.
            ENDCASE.
          ENDIF.
*       look for RISK LEVEL CRITICAL/DANGEROUS/HARMLESS
        WHEN &apos;RISK&apos;.
          y = state_end - x1.
*         there are enough tokens
          IF y &gt; 0.
            x1 = x1 + 1.
            READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
            IF token_rec-str = &apos;LEVEL&apos;.
              y = state_end - x1.
*             there are enough tokens
              IF y &gt; 0.
                x1 = x1 + 1.
                READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
                CASE token_rec-str.
                  WHEN &apos;HARMLESS&apos;.
                    class_rec-risk_level = const-aunit_risk-harmless.
                  WHEN &apos;DANGEROUS&apos;.
                    class_rec-risk_level = const-aunit_risk-dangerous.
                  WHEN &apos;CRITICAL&apos;.
                    class_rec-risk_level = const-aunit_risk-critical.
                ENDCASE.
              ENDIF.
            ENDIF.
          ENDIF.
*       look for INHERITING FROM x
        WHEN &apos;INHERITING&apos;.
          y = state_end - x1.
*         there are enough tokens
          IF y &gt; 1.
            x1 = x1 + 1.
            READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
            IF token_rec-str = &apos;FROM&apos;.
              x1 = x1 + 1.
              READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
              exted_rec-clsname    = class_rec-clsname.
              exted_rec-refclsname = token_rec-str.
              exted_rec-state      = me_priv-state.
              APPEND exted_rec TO exted_tab.
              me_priv-superclsname = token_rec-str.
            ENDIF.
          ENDIF.
*       look for CREATE PUBLIC/PROTECTED/PACKAGE/PRIVATE
        WHEN &apos;CREATE&apos;.
          y = state_end - x1.
*         there are enough tokens
          IF y &gt; 0.
            x1 = x1 + 1.
            READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
            CASE token_rec-str.
              WHEN &apos;PUBLIC&apos;.
                class_rec-exposure = 2.
              WHEN &apos;PROTECTED&apos;.
                class_rec-exposure = 1.
              WHEN &apos;PACKAGE&apos;.
                class_rec-exposure = 3.
              WHEN &apos;PRIVATE&apos;.
                class_rec-exposure = 0.
            ENDCASE.
          ENDIF.
*       look for ABSTRACT
        WHEN &apos;ABSTRACT&apos;.
          class_rec-clsabstrct = &apos;X&apos;.
*       look for FINAL
        WHEN &apos;FINAL&apos;.
          class_rec-clsfinal = &apos;X&apos;.
*       look for FRIENDS
        WHEN &apos;FRIENDS&apos;.
          x1 = x1 + 1.
          me-&gt;insert_frnds(
            EXPORTING
              clsname   = class_rec-clsname
              state_pos = x1
              state_end = state_end
            CHANGING
              frnds_tab = frnds_tab ).
          x1 = state_end.
*       look for GLOBAL FRIENDS
        WHEN &apos;GLOBAL&apos;.
          x1 = x1 + 2.
          me-&gt;insert_frnds(
            EXPORTING
              clsname   = class_rec-clsname
              state_pos = x1
              state_end = state_end
            CHANGING
              frnds_tab = frnds_tab ).
          x1 = state_end.
*       look for PUBLIC (just in case an already global class is scanned)
        WHEN &apos;PUBLIC&apos;.
*         ignore PUBLIC for global classes
*       look for SHARED MEMORY ENABLED
        WHEN &apos;OPEN&apos;.
          y = state_end - x1.
          IF y &gt; 1.
            x1 = x1 + 1.
            READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
            IF token_rec-str = &apos;FOR&apos;.
              x1 = x1 + 1.
              READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
              IF token_rec-str = &apos;PACKAGE&apos;.
*                class_rec-within_package = &apos;X&apos;.
              ELSE.
                x1 = x1 - 2.
              ENDIF.
            ELSE.
              x1 = x1 - 1.
            ENDIF.
          ENDIF.
      ENDCASE.
    ENDWHILE.
*   fill record and append it to table
    class_rec-version  = me_priv-version.
    class_rec-langu    = me_priv-langu.
    class_rec-state    = me_priv-state.
    class_rec-fixpt    = abap_true.
    APPEND class_rec TO class_tab.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLOAD" VERSION="1" LANGU="E" DESCRIPT="INSERT_CLOAD" EXPOSURE="0" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLOAD" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLOAD" SCONAME="CLOAD_TAB" VERSION="1" LANGU="E" DESCRIPT="CLOAD_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_CLOAT"/>
   <source>method INSERT_CLOAD.
*   importing state_pos type i
*   changing  cload_tab type saboo_cloat.
    DATA:
      cload_rec TYPE saboo_cload,
      token_re1 TYPE saboo_tokesx,
      x1         TYPE i.

* get the name of CLASS x DEFINITION LOAD
    x1 = state_pos + 1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
* fill record
    cload_rec-clsname   = me_priv-clsname.
    cload_rec-typegroup = token_re1-str.
* write entry to admin table
    APPEND cload_rec TO cload_tab.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EPARA" VERSION="1" LANGU="E" DESCRIPT="INSERT_EPARA" EXPOSURE="0" STATE="1" EDITORDER="19 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EPARA" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EPARA" SCONAME="CURRE_POS" VERSION="1" LANGU="E" DESCRIPT="CURRE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EPARA" SCONAME="EPARA_TAB" VERSION="1" LANGU="E" DESCRIPT="EPARA_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_EPART"/>
   <source>method INSERT_EPARA.
*  importing state_end type i
*  changing  curre_pos type i
*            epara_tab type saboo_epart.
    DATA:
      token_rec TYPE saboo_tokesx.

* look for exporting parameters
    CLEAR token_rec.
    READ TABLE me_priv-token_tab INTO token_rec INDEX curre_pos.
    IF ( curre_pos &lt;= state_end ) AND ( token_rec-str = &apos;EXPORTING&apos; ).
      curre_pos = curre_pos + 1.
      me-&gt;write_epara(
        EXPORTING
          pardecltyp = 1
          state_end  = state_end
        CHANGING
          curre_pos  = curre_pos
          epara_tab  = epara_tab ).
    ENDIF.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EVENT" VERSION="1" LANGU="E" DESCRIPT="INSERT_EVENT" EXPOSURE="0" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EVENT" SCONAME="EVTDECLTYP" VERSION="1" LANGU="E" DESCRIPT="EVTDECLTYP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="N"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EVENT" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EVENT" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EVENT" SCONAME="EVENT_TAB" VERSION="1" LANGU="E" DESCRIPT="EVENT_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_EVENT"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EVENT" SCONAME="EPARA_TAB" VERSION="1" LANGU="E" DESCRIPT="EPARA_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_EPART"/>
   <source>method INSERT_EVENT.
*   importing value(evtdecltyp) type n
*             state_pos         type i
*             state_end         type i
*   changing  event_tab         type saboo_event
*             epara_tab         type saboo_epart.
    DATA:
      event_rec TYPE saboo_evenx,
      token_re1 TYPE saboo_tokesx,
      curre_pos TYPE i,
      x1         TYPE i.

*   write default data for optional fields
    event_rec-redefin    = &apos; &apos;.
*   write kind of event
    event_rec-evtdecltyp = evtdecltyp.
*   get the name of event
    CLEAR token_re1.
    x1 = state_pos + 1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
    event_rec-cmpname = token_re1-str.
*   inside a event valid
    me_priv-cmpname = token_re1-str.
    curre_pos = state_pos + 2.
*   look for redefinition of event
    CLEAR token_re1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX curre_pos.
    IF ( curre_pos &lt;= state_end ) AND ( token_re1-str = &apos;REDEFINITION&apos; ).
      event_rec-redefin = &apos;X&apos;.
      curre_pos = curre_pos + 1.
    ENDIF.
*   fill record with global data and append it to table
    event_rec-clsname   = me_priv-clsname.
    event_rec-version   = me_priv-version.
    event_rec-langu     = me_priv-langu.
    event_rec-exposure  = me_priv-exposure.
    event_rec-state     = me_priv-state.
    event_rec-editorder = me_priv-editor_order. ADD 1 TO me_priv-editor_order.
    APPEND event_rec TO event_tab.
*   look for parameters
    IF curre_pos &lt;= state_end.
      me-&gt;insert_epara(
        EXPORTING
          state_end = state_end
        CHANGING
          curre_pos = curre_pos
          epara_tab = epara_tab ).
    ENDIF.
*   outside a event invalid
    me_priv-cmpname  = &apos;*** void ***&apos;.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_FRNDS" VERSION="1" LANGU="E" DESCRIPT="INSERT_FRNDS" EXPOSURE="0" STATE="1" EDITORDER="16 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_FRNDS" SCONAME="CLSNAME" VERSION="1" LANGU="E" DESCRIPT="CLSNAME" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CSEQUENCE"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_FRNDS" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_FRNDS" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_FRNDS" SCONAME="FRNDS_TAB" VERSION="1" LANGU="E" DESCRIPT="FRNDS_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_FRNDT"/>
   <source>method INSERT_FRNDS.
*   importing clsname type csequence
*             state_pos type i
*             state_end type i
*   changing  frnds_tab type saboo_frndt.

    DATA:
      x1         TYPE i,
      frnds_rec TYPE saboo_frnds,
      token_re1 TYPE saboo_tokesx.

* fill global components
    frnds_rec-clsname    = clsname.
    frnds_rec-friendtype = 0. &quot;insert always global friends
    frnds_rec-state      = me_priv-state.
    frnds_rec-version    = me_priv-version.
* loop over all classes/interfaces
    x1 = state_pos.
    WHILE x1 &lt;= state_end.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      frnds_rec-refclsname = token_re1-str.
      APPEND frnds_rec TO frnds_tab.
      x1 = x1 + 1.
    ENDWHILE.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_IIMPL" VERSION="1" LANGU="E" DESCRIPT="INSERT_IIMPL" EXPOSURE="0" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_IIMPL" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_IIMPL" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_IIMPL" SCONAME="IIMPL_TAB" VERSION="1" LANGU="E" DESCRIPT="IIMPL_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_IIMPT"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_IIMPL" SCONAME="REDEF_TAB" VERSION="1" LANGU="E" DESCRIPT="REDEF_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_REDET"/>
   <source>method INSERT_IIMPL.
*   importing state_pos type i
*             state_end type i
*   changing  iimpl_tab type saboo_iimpt
*             redef_tab type saboo_redet.

    DATA: iimpl_rec   TYPE saboo_iimpl,
          redef_rec   TYPE saboo_redef,
          token_re1   TYPE saboo_tokesx,
          token_re2   TYPE saboo_tokesx,
          token_re3   TYPE saboo_tokesx,
          x1           TYPE i,
          y           TYPE i,
          z           TYPE i,
          addition(1) TYPE c.

*   get name of interface
    x1 = state_pos + 1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
    iimpl_rec-refclsname = token_re1-str.
*   addition ABSTRACT/FINAL METHODS / ALL METHODS / DATA VALUE
    WHILE x1 &lt; state_end.
      y = state_end - x1.
      IF y &gt; 2.
*       look for stop words ABSTRACT/FINAL METHODS/ALL METHODS/DATA VALUE
        z = x1 + 1.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX z.
        z = z + 1.
        READ TABLE me_priv-token_tab INTO token_re2 INDEX z.
        IF token_re1-str = &apos;ABSTRACT&apos; AND token_re2-str = &apos;METHODS&apos;.
          addition = &apos;A&apos;. x1 = z.
        ELSEIF token_re1-str = &apos;FINAL&apos; AND token_re2-str = &apos;METHODS&apos;.
          addition = &apos;F&apos;. x1 = z.
        ELSEIF token_re1-str = &apos;ALL&apos; AND token_re2-str = &apos;METHODS&apos;.
          addition = &apos;M&apos;. x1 = z.
        ELSEIF token_re1-str = &apos;DATA&apos; AND token_re2-str = &apos;VALUES&apos;.
          addition = &apos;D&apos;. x1 = z.
        ENDIF.
      ENDIF.
*     depending on addition parse parameter
      CASE addition.
        WHEN &apos;A&apos;.
*         add ABSTRACT METHODS ... x ...
          ADD 1 TO x1.
          READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
*         fill redefinition table
          CLEAR redef_rec.
          redef_rec-clsname    = me_priv-clsname.
          redef_rec-version    = me_priv-version.
          redef_rec-refclsname = iimpl_rec-refclsname.
          redef_rec-mtdname    = token_re1-str.
          redef_rec-mtdabstrct = &apos;X&apos;.
          redef_rec-mtdfinal   = &apos;&apos;.
          redef_rec-attvalue   = &apos;&apos;.
          APPEND redef_rec TO redef_tab.
        WHEN &apos;F&apos;.
*         add FINAL METHODS ... x ...
          ADD 1 TO x1.
          READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
*         fill redefinition table
          CLEAR redef_rec.
          redef_rec-clsname    = me_priv-clsname.
          redef_rec-version    = me_priv-version.
          redef_rec-refclsname = iimpl_rec-refclsname.
          redef_rec-mtdname    = token_re1-str.
          redef_rec-mtdabstrct = &apos;&apos;.
          redef_rec-mtdfinal   = &apos;X&apos;.
          redef_rec-attvalue   = &apos;&apos;.
          APPEND redef_rec TO redef_tab.
        WHEN &apos;M&apos;.
*         add ALL METHODS ABSTARCT|FINAL
          ADD 1 TO x1.
          READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
          IF token_re1-str = &apos;ABSTRACT&apos;.
            iimpl_rec-impabstrct = &apos;X&apos;.
          ELSEIF token_re1-str = &apos;FINAL&apos;.
            iimpl_rec-impfinal = &apos;X&apos;.
          ENDIF.
*         ALL METHODS does not have a parameter list
          addition = &apos; &apos;.
        WHEN &apos;D&apos;.
*         add DATA VALUE x = y
          y = state_end - x1.
          IF y &gt; 2.
            ADD 1 TO x1.
            READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
            ADD 1 TO x1.
            READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
            ADD 1 TO x1.
            READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
            IF token_re2-str = &apos;=&apos;.
*             fill redefinition table
              CLEAR redef_rec.
              redef_rec-clsname    = me_priv-clsname.
              redef_rec-version    = me_priv-version.
              redef_rec-refclsname = iimpl_rec-refclsname.
              redef_rec-mtdname    = token_re1-str.
              redef_rec-mtdabstrct = &apos;&apos;.
              redef_rec-mtdfinal   = &apos;&apos;.
              redef_rec-attvalue   =  token_re3-str.
              APPEND redef_rec TO redef_tab.
            ELSE.
*             every list entry has to have the format x = y
              addition = &apos; &apos;.
            ENDIF.
          ELSE.
*           every list entry has to have the format x = y
            addition = &apos; &apos;.
          ENDIF.
        WHEN OTHERS.
*         in case you could not recognize a new addition, go ahead
          ADD 1 TO x1.
      ENDCASE.
    ENDWHILE.
*   write global data
    iimpl_rec-clsname   = me_priv-clsname.
    iimpl_rec-version   = me_priv-version.
    iimpl_rec-exposure  = me_priv-exposure.
    iimpl_rec-state     = me_priv-state.
*    iimpl_rec-editorder = me_priv-editor_order. add 1 to me_priv-editor_order.
*   append to tab
    APPEND iimpl_rec TO iimpl_tab.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_IINCL" VERSION="1" LANGU="E" DESCRIPT="INSERT_IINCL" EXPOSURE="0" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_IINCL" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_IINCL" SCONAME="IINCL_TAB" VERSION="1" LANGU="E" DESCRIPT="IINCL_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_IINCT"/>
   <source>method INSERT_IINCL.
*   importing state_pos type i
*   changing  iincl_tab type saboo_iinct.

    DATA: iincl_rec TYPE saboo_iincl,
          token_rec TYPE saboo_tokesx,
          x1         TYPE i.

* get name of interface
    x1 = state_pos + 1.
    READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
    iincl_rec-refclsname = token_rec-str.
* no more to do for now
* write global data
    iincl_rec-clsname  = me_priv-clsname.
    iincl_rec-version  = me_priv-version.
    iincl_rec-state    = me_priv-state.
* append to tab
    APPEND iincl_rec TO iincl_tab.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ILOAD" VERSION="1" LANGU="E" DESCRIPT="INSERT_ILOAD" EXPOSURE="0" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ILOAD" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ILOAD" SCONAME="ILOAD_TAB" VERSION="1" LANGU="E" DESCRIPT="ILOAD_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_ILOAT"/>
   <source>method INSERT_ILOAD.
* importing state_pos type i
* changing  iload_tab type saboo_iloat.

    DATA:
      iload_rec TYPE saboo_iload,
      token_re1 TYPE saboo_tokesx,
      x1         TYPE i.

* get the name of CLASS x DEFINITION LOAD
    x1 = state_pos + 1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
* fill record
    iload_rec-clsname   = me_priv-clsname.
    iload_rec-typegroup = token_re1-str.
* write entry to admin table
    APPEND iload_rec TO iload_tab.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_INTER" VERSION="1" LANGU="E" DESCRIPT="INSERT_INTER" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_INTER" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_INTER" SCONAME="INTER_TAB" VERSION="1" LANGU="E" DESCRIPT="INTER_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_INTET"/>
   <source>method INSERT_INTER.
*   importing state_pos type i
*   changing  inter_tab type saboo_intet.
    DATA:
      inter_rec TYPE saboo_inter,
      token_rec TYPE saboo_tokesx,
      x1         TYPE i.

* get the name of the interface
    x1 = state_pos + 1.
    READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
* fill record and append it to table
    inter_rec-clsname  = token_rec-str.
    inter_rec-version  = me_priv-version.
    inter_rec-langu    = me_priv-langu.
    inter_rec-exposure = me_priv-exposure.
    inter_rec-state    = me_priv-state.
    APPEND inter_rec TO inter_tab.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_METHO" VERSION="1" LANGU="E" DESCRIPT="INSERT_METHO" EXPOSURE="0" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_METHO" SCONAME="MTDDECLTYP" VERSION="1" LANGU="E" DESCRIPT="MTDDECLTYP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="N"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_METHO" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_METHO" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_METHO" SCONAME="METHO_TAB" VERSION="1" LANGU="E" DESCRIPT="METHO_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_METHT"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_METHO" SCONAME="REDEF_TAB" VERSION="1" LANGU="E" DESCRIPT="REDEF_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_REDET"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_METHO" SCONAME="MPARA_TAB" VERSION="1" LANGU="E" DESCRIPT="MPARA_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_MPART"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_METHO" SCONAME="MEXCE_TAB" VERSION="1" LANGU="E" DESCRIPT="MEXCE_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_MEXCT"/>
   <source>method INSERT_METHO.
*   importing value(mtddecltyp) type n
*             state_pos         type i
*             state_end         type i
*   changing  metho_tab         type saboo_metht
*             redef_tab         type saboo_redet
*             mpara_tab         type saboo_mpart
*             mexce_tab         type saboo_mexct.
    DATA:
      metho_rec TYPE saboo_metho,
      mpara_rec TYPE saboo_mpara,
      redef_rec TYPE saboo_redef,
      token_re1 TYPE saboo_tokesx,
      token_re2 TYPE saboo_tokesx,
      token_re3 TYPE saboo_tokesx,
      curre_pos TYPE i,
      x1         TYPE i.

* write default data for optional fields
    metho_rec-redefin    = &apos; &apos;.
    metho_rec-mtdabstrct = &apos; &apos;.
    metho_rec-mtdfinal   = &apos; &apos;.
* metho_rec-desnoteom  = &apos; &apos;.
    metho_rec-mtdtype    = 0.
    me_priv-mtdtype    = 0.
    metho_rec-refclsname = &apos;&apos;.
    metho_rec-refcmpname = &apos;&apos;.
* write kind of method
    metho_rec-mtddecltyp = mtddecltyp.
* get the name of method
    CLEAR token_re1.
    x1 = state_pos + 1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
    metho_rec-cmpname = token_re1-str.
    IF metho_rec-cmpname = &apos;CONSTRUCTOR&apos; OR  metho_rec-cmpname = &apos;CLASS_CONSTRUCTOR&apos;.
      metho_rec-mtdtype    = 2.
      me_priv-mtdtype    = 2.
    ELSEIF  metho_rec-cmpname = &apos;DESTRUCTOR&apos;.
      metho_rec-mtdtype    = 3.
      me_priv-mtdtype    = 3.
    ENDIF.
* inside a method valid
    me_priv-cmpname = token_re1-str.
    curre_pos = state_pos + 2.
    CLEAR token_re2.
    READ TABLE me_priv-token_tab INTO token_re2 INDEX curre_pos.
    x1 = curre_pos + 1.
    CLEAR token_re3.
    READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
* look for abstract method
    IF ( curre_pos &lt;= state_end ) AND ( token_re2-str = &apos;ABSTRACT&apos; ).
      metho_rec-mtdabstrct = &apos;X&apos;.
      redef_rec-mtdabstrct = &apos;X&apos;.
      curre_pos = curre_pos + 1.
* look for final method
    ELSEIF ( curre_pos &lt;= state_end ) AND ( token_re2-str = &apos;FINAL&apos; ).
      metho_rec-mtdfinal = &apos;X&apos;.
      redef_rec-mtdfinal = &apos;X&apos;.
      curre_pos = curre_pos + 1.
* look for DESTRUCTOR NOT AT END OF MODE
    ELSEIF ( curre_pos &lt;= state_end ) AND
           ( token_re1-str = &apos;DESTRUCTOR&apos; ) AND
           ( token_re2-str = &apos;NOT&apos; ) AND ( token_re3-str = &apos;AT&apos; ).
      x1 = curre_pos + 2.
      CLEAR token_re1.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      x1 = curre_pos + 3.
      CLEAR token_re2.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      x1 = curre_pos + 4.
      CLEAR token_re3.
      READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
      IF ( token_re1-str = &apos;END&apos; ) AND ( token_re2-str = &apos;OF&apos; ) AND
         ( token_re3-str = &apos;MODE&apos; ).
        metho_rec-dsrnoteom = &apos;X&apos;.
        ADD 5 TO curre_pos.
      ENDIF.
    ENDIF.
    CLEAR token_re2.
    READ TABLE me_priv-token_tab INTO token_re2 INDEX curre_pos.
    x1 = curre_pos + 1.
    CLEAR token_re3.
    READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
* look for testing
    IF ( token_re2-str = &apos;FOR&apos; ) AND ( token_re3-str = &apos;TESTING&apos; ).
      metho_rec-mtdtype    = 6.
      me_priv-mtdtype    = 6.
      curre_pos = curre_pos + 2.
    ENDIF.
    CLEAR token_re2.
    READ TABLE me_priv-token_tab INTO token_re2 INDEX curre_pos.
* look for redefinition of method
    IF ( curre_pos &lt;= state_end ) AND ( token_re2-str = &apos;REDEFINITION&apos; ).
*   for redefinitions we only fill redef_tab !!
      redef_rec-clsname    = me_priv-clsname.
      redef_rec-refclsname = me_priv-superclsname.
      redef_rec-mtdname    = token_re1-str.
      APPEND redef_rec TO redef_tab.
      RETURN.
    ENDIF.
* ? event method FOR EVENT
    CLEAR: token_re1, token_re2.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX curre_pos.
    x1 = curre_pos + 1.
    READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
* ? enough tokens left
    x1 = curre_pos + 4.
    IF ( x1 &lt;= state_end ) AND
       ( token_re1-str = &apos;FOR&apos; ) AND ( token_re2-str = &apos;EVENT&apos; ).
      CLEAR: token_re1, token_re2, token_re3.
      x1 = curre_pos + 2.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      x1 = curre_pos + 3.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      x1 = curre_pos + 4.
      READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*   ? FOR EVENT x OF y
      IF ( token_re2-str = &apos;OF&apos; ).
        metho_rec-refclsname = token_re3-str.
        SPLIT token_re1-str AT &apos;~&apos;
          INTO metho_rec-refintname
          metho_rec-refcmpname.
        IF metho_rec-refcmpname = &apos;&apos;.
          metho_rec-refcmpname = metho_rec-refintname.
          metho_rec-refintname = &apos;&apos;.
        ENDIF.
        metho_rec-mtdtype    = 1.
        me_priv-mtdtype    = 1.
        curre_pos = curre_pos + 5.
        IF curre_pos &lt;= state_end.
*       read next token
          CLEAR token_re1.
          READ TABLE me_priv-token_tab INTO token_re1 INDEX curre_pos.
*       scan for IMPORTING
          IF ( curre_pos &lt;= state_end ) AND
             ( token_re1-str = &apos;IMPORTING&apos; ).
            curre_pos = curre_pos + 1.
*         scan for handler parameter
            WHILE curre_pos &lt;= state_end.
*           read next token
              CLEAR token_re1.
              READ TABLE me_priv-token_tab INTO token_re1 INDEX curre_pos.
*           fill name and type of parameter
              mpara_rec-sconame    = token_re1-str.
              mpara_rec-parpasstyp = 0.
              mpara_rec-pardecltyp = 0.
              mpara_rec-typtype    = 0.
*           fill global record and append it
              mpara_rec-clsname    = me_priv-clsname.
              mpara_rec-cmpname    = me_priv-cmpname.
              mpara_rec-version    = me_priv-version.
              mpara_rec-langu      = me_priv-langu.
              mpara_rec-mtdtype    = me_priv-mtdtype.
              APPEND mpara_rec TO mpara_tab.
              curre_pos = curre_pos + 1.
            ENDWHILE.
          ENDIF.
        ENDIF.
      ENDIF.
    ELSE.
*   look for parameters
      IF curre_pos &lt;= state_end.
        me-&gt;insert_mpara(
          EXPORTING
            state_end = state_end
          CHANGING
            curre_pos = curre_pos
            mpara_tab = mpara_tab ).
      ENDIF.
*   look for exceptions
      IF curre_pos &lt;= state_end.
        me-&gt;insert_mexec(
          EXPORTING
            state_end = state_end
          CHANGING
            curre_pos = curre_pos
            mtdnewexc = metho_rec-mtdnewexc
            mexce_tab = mexce_tab ).
      ENDIF.
    ENDIF.
* fill record with global data and append it to table
    metho_rec-clsname    = me_priv-clsname.
    metho_rec-version    = me_priv-version.
    metho_rec-langu      = me_priv-langu.
    metho_rec-exposure   = me_priv-exposure.
    metho_rec-state      = me_priv-state.
    metho_rec-editorder  = me_priv-editor_order. ADD 1 TO me_priv-editor_order.
    APPEND metho_rec TO metho_tab.
* outside a method invalid
    me_priv-cmpname  = &apos;*** void ***&apos;.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MEXEC" VERSION="1" LANGU="E" DESCRIPT="INSERT_MEXEC" EXPOSURE="0" STATE="1" EDITORDER="18 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MEXEC" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MEXEC" SCONAME="CURRE_POS" VERSION="1" LANGU="E" DESCRIPT="CURRE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MEXEC" SCONAME="MTDNEWEXC" VERSION="1" LANGU="E" DESCRIPT="MTDNEWEXC" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SEONEWEXC"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MEXEC" SCONAME="MEXCE_TAB" VERSION="1" LANGU="E" DESCRIPT="MEXCE_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_MEXCT"/>
   <source>method INSERT_MEXEC.
*   importing state_end type i
*   changing  curre_pos type i
*             mtdnewexc type seonewexc
*             mexce_tab type saboo_mexct.

    DATA:
      excp_name TYPE c LENGTH 30,
      mexce_rec TYPE saboo_mexce,
      token_rec TYPE saboo_tokesx.

    READ TABLE me_priv-token_tab INTO token_rec INDEX curre_pos.
* ? RAISING ....
    IF token_rec-str = &apos;RAISING&apos;.
      mtdnewexc = &apos;X&apos;.
    ELSE.
      mtdnewexc = &apos;&apos;.
    ENDIF.
* ? EXCEPTIONS ... or RAISING ...
    IF token_rec-str = &apos;EXCEPTIONS&apos; OR mtdnewexc = &apos;X&apos;.
      DO.
        curre_pos = curre_pos + 1.
*     ? end of statement
        IF curre_pos &gt; state_end.
          EXIT.
        ENDIF.
*     read exception name
        CLEAR: token_rec, mexce_rec.
        READ TABLE me_priv-token_tab INTO token_rec INDEX curre_pos.
*     fill record and append it
        IF strlen( token_rec-str ) &gt; 12 AND token_rec-str(10) = &apos;RESUMABLE(&apos;.
          DATA dummy TYPE c LENGTH 1.                       &quot;#EC NEEDED
          SPLIT token_rec-str+10(*) AT &apos;)&apos; INTO excp_name dummy.
          mexce_rec-is_resumable = abap_true.
        ELSE.
          mexce_rec-is_resumable = abap_false.
          excp_name = token_rec-str.
        ENDIF.
        mexce_rec-sconame   = excp_name.
        mexce_rec-clsname   = me_priv-clsname.
        mexce_rec-cmpname   = me_priv-cmpname.
        mexce_rec-version   = me_priv-version.
        mexce_rec-langu     = me_priv-langu.
        mexce_rec-mtdtype   = me_priv-mtdtype.
        mexce_rec-editorder = me_priv-editor_order. ADD 1 TO me_priv-editor_order.
        APPEND mexce_rec TO mexce_tab.
      ENDDO.
    ENDIF.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MPARA" VERSION="1" LANGU="E" DESCRIPT="INSERT_MPARA" EXPOSURE="0" STATE="1" EDITORDER="17 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MPARA" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MPARA" SCONAME="CURRE_POS" VERSION="1" LANGU="E" DESCRIPT="CURRE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MPARA" SCONAME="MPARA_TAB" VERSION="1" LANGU="E" DESCRIPT="MPARA_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_MPART"/>
   <source>method INSERT_MPARA.
*   importing state_end type i
*   changing  curre_pos type i
*             mpara_tab type saboo_mpart.

    DATA:
      token_rec TYPE saboo_tokesx.

* look for importing parameters
    CLEAR token_rec.
    READ TABLE me_priv-token_tab INTO token_rec INDEX curre_pos.
    IF ( curre_pos &lt;= state_end ) AND ( token_rec-str = &apos;IMPORTING&apos; ).
      curre_pos = curre_pos + 1.
      me-&gt;write_mpara(
        EXPORTING
          pardecltyp = 0
          state_end  = state_end
        CHANGING
          curre_pos  = curre_pos
          mpara_tab  = mpara_tab ).
    ENDIF.
* look for exporting parameters
    CLEAR token_rec.
    READ TABLE me_priv-token_tab INTO token_rec INDEX curre_pos.
    IF ( curre_pos &lt;= state_end ) AND ( token_rec-str = &apos;EXPORTING&apos; ).
      curre_pos = curre_pos + 1.
      me-&gt;write_mpara(
        EXPORTING
          pardecltyp = 1
          state_end  = state_end
        CHANGING
          curre_pos  = curre_pos
          mpara_tab  = mpara_tab ).
    ENDIF.
* look for changing parameters
    CLEAR token_rec.
    READ TABLE me_priv-token_tab INTO token_rec INDEX curre_pos.
    IF ( curre_pos &lt;= state_end ) AND ( token_rec-str = &apos;CHANGING&apos; ).
      curre_pos = curre_pos + 1.
      me-&gt;write_mpara(
        EXPORTING
          pardecltyp = 2
          state_end  = state_end
        CHANGING
          curre_pos  = curre_pos
          mpara_tab  = mpara_tab ).
    ENDIF.
* look for returning parameters
    CLEAR token_rec.
    READ TABLE me_priv-token_tab INTO token_rec INDEX curre_pos.
    IF ( curre_pos &lt;= state_end ) AND ( token_rec-str = &apos;RETURNING&apos; ).
      curre_pos = curre_pos + 1.
      me-&gt;write_mpara(
        EXPORTING
          pardecltyp = 3
          state_end  = state_end
        CHANGING
          curre_pos  = curre_pos
          mpara_tab  = mpara_tab ).
    ENDIF.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_TPOOL" VERSION="1" LANGU="E" DESCRIPT="INSERT_TPOOL" EXPOSURE="0" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_TPOOL" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_TPOOL" SCONAME="TPOOL_TAB" VERSION="1" LANGU="E" DESCRIPT="TPOOL_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_TPOOT"/>
   <source>method INSERT_TPOOL.
*    importing state_pos type i
*    changing  tpool_tab type saboo_tpoot.

    DATA:
      tpool_rec TYPE saboo_tpool,
      token_re1 TYPE saboo_tokesx,
      x1         TYPE i.

* get the name of CLASS x DEFINITION LOAD
    x1 = state_pos + 1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
* fill record
    tpool_rec-clsname   = me_priv-clsname.
    tpool_rec-typegroup = token_re1-str.
* write entry to admin table
    APPEND tpool_rec TO tpool_tab.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_TYPES" VERSION="1" LANGU="E" DESCRIPT="INSERT_TYPES" EXPOSURE="0" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_TYPES" SCONAME="STATE_BEGIN" VERSION="1" LANGU="E" DESCRIPT="STATE_BEGIN" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_TYPES" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_TYPES" SCONAME="TYPES_TAB" VERSION="1" LANGU="E" DESCRIPT="TYPES_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_TYPET"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_TYPES" SCONAME="TYPSR_TAB" VERSION="1" LANGU="E" DESCRIPT="TYPSR_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_TYPST"/>
   <source>method INSERT_TYPES.
*   importing state_begin       type i
*             state_end         type i
*   changing  types_tab         type saboo_typet
*             typsr_tab         type saboo_typst.
    DATA:
      types_rec    TYPE saboo_types,
      token_re1    TYPE saboo_tokesx,
      token_re2    TYPE saboo_tokesx,
      token_re3    TYPE saboo_tokesx,
      typsr_rec    TYPE saboo_typsr,
      cursor       TYPE i,
      state_lenght TYPE i,
      x1            TYPE i,
      typ_name(30) TYPE c,
      fl_size(30)  TYPE c.

* write default data for optional fields
    types_rec-typtype    = 1.
    types_rec-type       = &apos;C&apos;.
* fill record with global data
    types_rec-clsname   = me_priv-clsname.
    types_rec-version   = me_priv-version.
    types_rec-langu     = me_priv-langu.
    types_rec-exposure  = me_priv-exposure.
    types_rec-state     = me_priv-state.
    types_rec-editorder = me_priv-editor_order. ADD 1 TO me_priv-editor_order.
* initialize state length, left and right cursor
    state_lenght = state_end - state_begin + 1.
    cursor = state_begin + 1.
* type declaration greater than TYPES X.
    IF state_lenght &gt; 2.
*   look for type, scan from left side
      CLEAR: token_re1, token_re2, token_re3.
      x1 = cursor + 1.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      x1 = cursor + 2.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      x1 = cursor + 3.
      READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*   ? TYPES x TYPE REF TO a ...
      IF ( state_lenght &gt;= 5 ) AND ( token_re1-str = &apos;TYPE&apos; ) AND
         ( token_re2-str = &apos;REF&apos; ) AND ( token_re3-str = &apos;TO&apos; ).
        x1 = cursor + 4.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
        types_rec-typtype = 3.
        types_rec-type    = token_re1-str.
        cursor            = cursor + 4.
*   ? TYPES x TYPE a ...
      ELSEIF ( state_lenght &gt;= 4 ) AND ( token_re1-str = &apos;TYPE&apos; ).
        types_rec-typtype = 1.
        types_rec-type    = token_re2-str.
        cursor            = cursor + 2.
*   ? DATA x LIKE a ...
      ELSEIF ( state_lenght &gt;= 4 ) AND ( token_re1-str = &apos;LIKE&apos; ).
        types_rec-typtype = 0.
        types_rec-type    = token_re2-str.
        cursor            = cursor + 2.
*   ? BEGIN OF x | END OF x
      ELSEIF ( state_lenght &gt;= 4 ) AND ( token_re1-str = &apos;OF&apos; ).
        CLEAR token_re1.
        x1 = cursor.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
        CASE token_re1-str.
*       flag inside BEGIN ... END declaration
          WHEN &apos;BEGIN&apos;.
*         ? nested BEGIN ... END
            IF me_priv-inside_begin_end &gt; 0.
              me_priv-inside_begin_end = me_priv-inside_begin_end + 1.
            ELSE.
              me_priv-inside_begin_end = 1.
              me_priv-begin_end_row    = token_re1-row.
              me_priv-begin_end_col    = token_re1-col.
            ENDIF.
*       end of BEGIN .. END declaration write attribute and source table
          WHEN &apos;END&apos;.
*         END without BEGIN -&gt; error
            IF me_priv-inside_begin_end = 0.
*              raise resumable exception type statement_illegal.
              RETURN.
            ENDIF.
            me_priv-inside_begin_end = me_priv-inside_begin_end - 1.
*         ? nested BEGIN ... END
            IF me_priv-inside_begin_end &gt; 0.
              RETURN.
            ENDIF.
*         append to source table
            typsr_rec-clsname   = me_priv-clsname.
            typsr_rec-cmpname   = token_re2-str.
            typsr_rec-begin_row = me_priv-begin_end_row.
            typsr_rec-begin_col = me_priv-begin_end_col.
            typsr_rec-end_row   = token_re2-row.
            typsr_rec-end_col   = token_re2-col + strlen( token_re2-str ) - 1.
            APPEND typsr_rec TO typsr_tab.
*         insert source
            me-&gt;source_tab_to_char( EXPORTING typsr_rec = typsr_rec CHANGING char = types_rec-typesrc ).
*         append to attribute table
            types_rec-cmpname = token_re2-str.
            types_rec-typtype = 4.
            types_rec-type    = space.
            APPEND types_rec TO types_tab.
        ENDCASE.
        RETURN.
      ENDIF.
    ENDIF.
* ? inside a BGIN of x ... END of x declaration
    IF me_priv-inside_begin_end &gt; 0.
      RETURN.
    ENDIF.
* get the name of attribute
    CLEAR: token_re1, typ_name, fl_size.
    x1 = state_begin + 1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
* ? xxx(yyy)
    SPLIT token_re1-str AT &apos;(&apos; INTO typ_name fl_size.
    DATA dummy TYPE c LENGTH 1.                             &quot;#EC NEEDED
    SPLIT fl_size AT &apos;)&apos; INTO fl_size dummy.
    types_rec-cmpname = typ_name.
* ? complex type
    IF ( cursor &lt; state_end ) OR ( fl_size &lt;&gt; &apos;&apos; ).
*   fill and append record to type-source table
      CLEAR: token_re1, token_re2.
      x1 = state_begin + 1.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      x1 = state_end.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      typsr_rec-clsname   = me_priv-clsname.
      typsr_rec-cmpname   = typ_name.
      typsr_rec-begin_row = token_re1-row.
      typsr_rec-begin_col = token_re1-col.
      typsr_rec-end_row   = token_re2-row.
      typsr_rec-end_col   = token_re2-col + strlen( token_re2-str ) - 1.
      APPEND typsr_rec TO typsr_tab.
*   insert source
      me-&gt;source_tab_to_char( EXPORTING typsr_rec = typsr_rec CHANGING char = types_rec-typesrc ).
*   update attribut record
      types_rec-typtype = 4.
      types_rec-type    = space.
    ENDIF.
* append record to attribute table
    APPEND types_rec TO types_tab.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="RESET" VERSION="1" LANGU="E" DESCRIPT="RESET" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method RESET.
    me_priv-clsname           = &apos;*** void ***&apos;. &quot; outside a definition invalid
    me_priv-superclsname      = &apos;*** void ***&apos;. &quot; outside a definition invalid
    me_priv-cmpname           = &apos;*** void ***&apos;. &quot; outside method/event invalid
    me_priv-version           = 1.              &quot; default is ACTIV
    me_priv-langu             = sy-langu.       &quot; get system langage
    me_priv-exposure          = const-exposure-public.&quot; default is PUBLIC
    me_priv-state             = 1.              &quot; default is impl. and not modl.
    me_priv-mtdtype           = 0.              &quot; default normal method
    me_priv-editor_order      = 1.              &quot; reset counter for editor order
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="RESOLVE_INCLUDES" VERSION="1" LANGU="E" DESCRIPT="RESOLVE_INCLUDES" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="RESOLVE_INCLUDES" SCONAME="SOURC_TAB" VERSION="1" LANGU="E" DESCRIPT="SOURC_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_SOURT"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="RESOLVE_INCLUDES" SCONAME="ERROR_SOURCE" VERSION="1" LANGU="E" DESCRIPT="ERROR_SOURCE" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SYST-REPID"/>
   <source>method RESOLVE_INCLUDES.
*   changing p_sourc_tab type saboo_sourt
*            p_error_source type syst-repid.

    TYPES: BEGIN OF include_ret,
             statement  TYPE saboo_state,
             sourc_tab  TYPE saboo_sourt,
           END OF include_ret,
           include_tat TYPE STANDARD TABLE OF include_ret WITH DEFAULT KEY.

    DATA: prog_tab    TYPE saboo_sourt,
          sourl_tab   TYPE saboo_sourt,
          token_rec   TYPE saboo_tokes,
          index       TYPE i,
          index2      TYPE i,
          include_tab TYPE include_tat,
          include_wa  TYPE include_ret,
          lstate_tab   TYPE saboo_statt,
          ltoken_tab   TYPE saboo_tokst,
          incl_name(40) TYPE c.

    FIELD-SYMBOLS: &lt;state_wa&gt;   TYPE saboo_state,
                   &lt;include_wa&gt; TYPE include_ret.

*   scan to get tokens and statements
    SCAN ABAP-SOURCE sourc_tab TOKENS     INTO ltoken_tab
                               STATEMENTS INTO lstate_tab.
*   look for INCLUDE statements
    LOOP AT lstate_tab ASSIGNING &lt;state_wa&gt; WHERE type = &apos;I&apos;.
*     read second token (name of program to by included)
      index = &lt;state_wa&gt;-to.
      READ TABLE ltoken_tab INTO token_rec INDEX index.
*     read program and append to source table
      CLEAR: prog_tab.
      incl_name = token_rec-str.
      CLEAR prog_tab.
      READ REPORT incl_name INTO prog_tab.
      APPEND LINES OF prog_tab TO sourl_tab.
*     the last statement has terminator . (chained-statement ,)
      IF &lt;state_wa&gt;-terminator = &apos;.&apos;.
*       recursive descent
        me-&gt;resolve_includes( CHANGING sourc_tab = sourl_tab error_source = error_source ).
*       append include source to include table
        include_wa-statement = &lt;state_wa&gt;.
        include_wa-sourc_tab = sourl_tab.
        INSERT include_wa INTO include_tab INDEX 1.
*       refresh source collection table
        CLEAR: sourl_tab.
      ENDIF.
    ENDLOOP.
*   insert source from includes to source tabel
    LOOP AT include_tab ASSIGNING &lt;include_wa&gt;.
*     delete INCLUDE statements
      READ TABLE ltoken_tab INTO token_rec
        INDEX &lt;include_wa&gt;-statement-from.
      index  = token_rec-row.
      READ TABLE ltoken_tab INTO token_rec
        INDEX &lt;include_wa&gt;-statement-to.
      index2 = token_rec-row.
      DELETE sourc_tab FROM index TO index2.
*     insert include source
      INSERT LINES OF &lt;include_wa&gt;-sourc_tab
        INTO sourc_tab INDEX index.
    ENDLOOP.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCAN_SOURCE" VERSION="1" LANGU="E" DESCRIPT="SCAN_SOURCE" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCAN_SOURCE" SCONAME="CLSNAME" VERSION="1" LANGU="E" DESCRIPT="CLSNAME" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCLASS-CLSNAME" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCAN_SOURCE" SCONAME="SUPERCLSNAME" VERSION="1" LANGU="E" DESCRIPT="SUPERCLSNAME" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCLASS-CLSNAME" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCAN_SOURCE" SCONAME="EXPOSURE" VERSION="1" LANGU="E" DESCRIPT="EXPOSURE" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="VSEOCLASS-EXPOSURE" PARVALUE="2"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCAN_SOURCE" SCONAME="VSEO_TABS" VERSION="1" LANGU="E" DESCRIPT="VSEO_TABS" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SABOO_VSEOT"/>
   <source>method SCAN_SOURCE.

    DATA:
      token_re1 TYPE saboo_tokesx,
      token_re2 TYPE saboo_tokesx,
      token_re3 TYPE saboo_tokesx,
      state_rec TYPE saboo_state,
      state_len TYPE i,
      x1        TYPE i,
      scope_rec TYPE scope_rec_type.

    me-&gt;reset( ).

*   set class context, if passed
    IF clsname IS NOT INITIAL.
      me_priv-clsname  = clsname.
      IF superclsname IS NOT INITIAL.
        me_priv-superclsname = superclsname.
      ENDIF.
      me_priv-exposure = exposure.
*     increase the nested scope because we are inside a definition
      me_priv-nested_sc = me_priv-nested_sc + 1.
      scope_rec-clsname  = clsname.
      scope_rec-exposure = exposure.
      INSERT scope_rec INTO me_priv-scope_sta INDEX 1.
    ENDIF.

*   main loop to fill all tables
    LOOP AT me_priv-state_tab INTO state_rec.
*     no empty statements
      CHECK state_rec-from &lt;= state_rec-to.
      state_len = state_rec-to - state_rec-from + 1.
*     get the first three tokens, if available
      CLEAR: token_re1, token_re2, token_re3.
      x1 = state_rec-from.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      x1 = x1 + 1.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      x1 = x1 + 1.
      READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*     look for CLASS X DEFINITION statement
      IF ( token_re1-str = &apos;CLASS&apos; ) AND
         ( token_re3-str = &apos;DEFINITION&apos; ).
        x1 = x1 + 1.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
*       CLASS xxx DEFINITION DEFERRED.
        IF state_len = 4 AND token_re1-str = &apos;DEFERRED&apos;.
*       ignore
*       CLASS xxx DEFINITION LOAD.
        ELSEIF state_len = 4 AND token_re1-str = &apos;LOAD&apos;.
          IF me_priv-nested_sc &gt; 0.
*         CLASS x DEFINITION LOAD inside CLASS ... ENDCLASS.
            me-&gt;insert_cload(
              EXPORTING
                state_pos = state_rec-from
              CHANGING
                cload_tab = vseo_tabs-cload_tab ).
          ENDIF.
*       CLASS x DEFINITION LOCAL FRIENDS ....
        ELSEIF state_len &gt; 5 AND token_re1-str = &apos;LOCAL&apos;.
          x1 = x1 + 2.
          me-&gt;insert_frnds(
            EXPORTING
              clsname   = token_re2-str
              state_pos = x1
              state_end = state_rec-to
            CHANGING
              frnds_tab = vseo_tabs-frnds_tab ).
*       CLASS x DEFINITION ....
        ELSE.
*         initial global structure
          me_priv-superclsname = &apos;*** void ***&apos;. &quot; for interfaces invalid
*         build and insert new record for class
          me-&gt;insert_class(
            EXPORTING
              state_begin = state_rec-from
              state_end   = state_rec-to
            CHANGING
              class_tab   = vseo_tabs-class_tab
              exted_tab   = vseo_tabs-exted_tab
              frnds_tab   = vseo_tabs-frnds_tab ).
*         increase the nested scope
          me_priv-nested_sc    = me_priv-nested_sc + 1.
          me_priv-clsname      = token_re2-str.
          me_priv-is_interface = &apos; &apos;.
          scope_rec-clsname      = me_priv-clsname.
          scope_rec-superclsname = me_priv-superclsname.
          scope_rec-is_interface = me_priv-is_interface.
          scope_rec-exposure     = me_priv-exposure.
          INSERT scope_rec INTO me_priv-scope_sta INDEX 1.
*         initial global structure
          me_priv-exposure = 2. &quot; default inside new definition PUBLIC
        ENDIF.
*     look for INTERFACE X ... statement
      ELSEIF token_re1-str = &apos;INTERFACE&apos;.
*       INTEFACE x [PUBLIC]. (just in case for an already global interface)
        IF state_len = 2 OR token_re3-str = &apos;PUBLIC&apos;.
*         build and insert new record for interface
          me-&gt;insert_inter(
            EXPORTING
              state_pos = state_rec-from
            CHANGING
              inter_tab = vseo_tabs-inter_tab ).
*         increase the nested scope
          me_priv-nested_sc    = me_priv-nested_sc + 1.
          me_priv-clsname      = token_re2-str.
          me_priv-superclsname = &apos;*** void ***&apos;. &quot; for interfaces invalid
          me_priv-is_interface = &apos;X&apos;.
          me_priv-editor_order = 1.
          scope_rec-clsname      = me_priv-clsname.
          scope_rec-superclsname = me_priv-superclsname.
          scope_rec-is_interface = me_priv-is_interface.
          scope_rec-exposure     = me_priv-exposure.
          INSERT scope_rec INTO me_priv-scope_sta INDEX 1.
          me_priv-exposure = 2. &quot; default inside new definition PUBLIC
*       INTERFACE x LOAD inside
        ELSEIF state_len = 3 AND token_re3-str = &apos;LOAD&apos; AND
               me_priv-nested_sc &gt; 0.
          me-&gt;insert_iload(
            EXPORTING
              state_pos = state_rec-from
            CHANGING
              iload_tab = vseo_tabs-iload_tab ).
        ENDIF.
*     look for ENDCLASS or ENDINTERFACE statement
      ELSEIF ( state_len = 1 ) AND
             ( ( token_re1-str = &apos;ENDCLASS&apos; ) OR
               ( token_re1-str = &apos;ENDINTERFACE&apos; ) ).
*       decrease the nested scope
        IF me_priv-nested_sc &gt; 0.
          READ TABLE me_priv-scope_sta INDEX 1 INTO scope_rec.
          me_priv-exposure = scope_rec-exposure.
          DELETE me_priv-scope_sta INDEX 1.
          IF me_priv-nested_sc = 1.
            me_priv-nested_sc    = 0.
            me_priv-clsname      = &apos;*** void ***&apos;.
            me_priv-superclsname = &apos;*** void ***&apos;.
            me_priv-is_interface = &apos; &apos;.
          ELSE.
            me_priv-nested_sc = me_priv-nested_sc - 1.
            READ TABLE me_priv-scope_sta INDEX 1 INTO scope_rec.
            me_priv-clsname      = scope_rec-clsname.
            me_priv-superclsname = scope_rec-superclsname.
            me_priv-is_interface = scope_rec-is_interface.
          ENDIF.
        ENDIF.
*     TYPE-POOLS x.
      ELSEIF state_len = 2 AND token_re1-str = &apos;TYPE-POOLS&apos;.
        me-&gt;insert_tpool(
          EXPORTING
            state_pos = state_rec-from
          CHANGING
            tpool_tab = vseo_tabs-tpool_tab ).
*     look whether we are already inside definition
      ELSEIF me_priv-nested_sc &gt; 0.
        CASE token_re1-str.
*         find token PUBLIC
          WHEN &apos;PUBLIC&apos;.
*         find PUBLIC SECTION statement
            IF ( state_len = 2 ) AND ( token_re2-str = &apos;SECTION&apos; ).
              me_priv-exposure     = const-exposure-public.
              me_priv-editor_order = 1.
            ENDIF.
*         find token PROTECTED
          WHEN &apos;PROTECTED&apos;.
*         find PROTECTED SECTION statement
            IF ( state_len = 2 ) AND ( token_re2-str = &apos;SECTION&apos; ).
              me_priv-exposure     = const-exposure-protected.
              me_priv-editor_order = 1.
            ENDIF.
*         find token PACKAGE
          WHEN &apos;PACKAGE&apos;.
*         find PACKAGE SECTION statement
            IF ( state_len = 2 ) AND ( token_re2-str = &apos;SECTION&apos; ).
              me_priv-exposure     = const-exposure-package.
              me_priv-editor_order = 1.
            ENDIF.
*         find token PRIVATE
          WHEN &apos;PRIVATE&apos;.
*         find PRIVATE SECTION statement
            IF ( state_len = 2 ) AND ( token_re2-str = &apos;SECTION&apos; ).
              me_priv-exposure     = const-exposure-private.
              me_priv-editor_order = 1.
            ENDIF.
*         find constants
          WHEN &apos;CONSTANTS&apos;.
            me-&gt;insert_attri(
              EXPORTING
                attdecltyp  = 2
                state_begin = state_rec-from
                state_end   = state_rec-to
              CHANGING
                attri_tab   = vseo_tabs-attri_tab
                typsr_tab   = vseo_tabs-typsr_tab ).
*         find attributes
          WHEN &apos;DATA&apos;.
            me-&gt;insert_attri(
              EXPORTING
                attdecltyp  = 0
                state_begin = state_rec-from
                state_end   = state_rec-to
              CHANGING
                attri_tab   = vseo_tabs-attri_tab
                typsr_tab   = vseo_tabs-typsr_tab ).
*         find class attributes
          WHEN &apos;CLASS-DATA&apos;.
            me-&gt;insert_attri(
              EXPORTING
                attdecltyp  = 1
                state_begin = state_rec-from
                state_end   = state_rec-to
              CHANGING
                attri_tab   = vseo_tabs-attri_tab
                typsr_tab   = vseo_tabs-typsr_tab ).
*         find methods
          WHEN &apos;METHODS&apos;.
            CALL FUNCTION &apos;RS_QUALIFY_ABAP_TOKENS_STR&apos;
              EXPORTING
                statement_type = state_rec-type
                index_from     = state_rec-from
                index_to       = state_rec-to
              CHANGING
                stokesx_tab    = me_priv-token_tab.
            me-&gt;insert_metho(
              EXPORTING
                mtddecltyp = 0
                state_pos  = state_rec-from
                state_end  = state_rec-to
              CHANGING
                metho_tab  = vseo_tabs-metho_tab
                redef_tab  = vseo_tabs-redef_tab
                mpara_tab  = vseo_tabs-mpara_tab
                mexce_tab  = vseo_tabs-mexce_tab ).
*         find class methods
          WHEN &apos;CLASS-METHODS&apos;.
            CALL FUNCTION &apos;RS_QUALIFY_ABAP_TOKENS_STR&apos;
              EXPORTING
                statement_type = state_rec-type
                index_from     = state_rec-from
                index_to       = state_rec-to
              CHANGING
                stokesx_tab    = me_priv-token_tab.
            me-&gt;insert_metho(
              EXPORTING
                mtddecltyp = 1
                state_pos  = state_rec-from
                state_end  = state_rec-to
              CHANGING
                metho_tab  = vseo_tabs-metho_tab
                redef_tab  = vseo_tabs-redef_tab
                mpara_tab  = vseo_tabs-mpara_tab
                mexce_tab  = vseo_tabs-mexce_tab ).
*         find events
          WHEN &apos;EVENTS&apos;.
            CALL FUNCTION &apos;RS_QUALIFY_ABAP_TOKENS_STR&apos;
              EXPORTING
                statement_type = state_rec-type
                index_from     = state_rec-from
                index_to       = state_rec-to
              CHANGING
                stokesx_tab    = me_priv-token_tab.
            me-&gt;insert_event(
              EXPORTING
                evtdecltyp = 0
                state_pos  = state_rec-from
                state_end  = state_rec-to
              CHANGING
                event_tab  = vseo_tabs-event_tab
                epara_tab  = vseo_tabs-epara_tab ).
*         find class events
          WHEN &apos;CLASS-EVENTS&apos;.
            CALL FUNCTION &apos;RS_QUALIFY_ABAP_TOKENS_STR&apos;
              EXPORTING
                statement_type = state_rec-type
                index_from     = state_rec-from
                index_to       = state_rec-to
              CHANGING
                stokesx_tab    = me_priv-token_tab.
            me-&gt;insert_event(
              EXPORTING
                evtdecltyp = 1
                state_pos  = state_rec-from
                state_end  = state_rec-to
              CHANGING
                event_tab  = vseo_tabs-event_tab
                epara_tab  = vseo_tabs-epara_tab ).
*         find interfaces (impl.)
          WHEN &apos;INTERFACES&apos;.
            IF me_priv-is_interface = &apos;X&apos;.
              me-&gt;insert_iincl(
                EXPORTING
                  state_pos = state_rec-from
                CHANGING
                  iincl_tab = vseo_tabs-iincl_tab ).
            ELSE.
              me-&gt;insert_iimpl(
                EXPORTING
                  state_pos = state_rec-from
                  state_end = state_rec-to
                CHANGING
                  iimpl_tab = vseo_tabs-iimpl_tab
                  redef_tab = vseo_tabs-redef_tab ).
            ENDIF.
*         find type definition
          WHEN &apos;TYPES&apos;.
            me-&gt;insert_types(
              EXPORTING
                state_begin = state_rec-from
                state_end   = state_rec-to
              CHANGING
                types_tab   = vseo_tabs-types_tab
                typsr_tab   = vseo_tabs-typsr_tab ).
*         find alias definition
          WHEN &apos;ALIASES&apos;.
            me-&gt;insert_alias(
              EXPORTING
                state_pos = state_rec-from
                state_end = state_rec-to
              CHANGING
                alias_tab = vseo_tabs-alias_tab ).
*         find INCLUDE /TYPE/STRUCTURE
          WHEN &apos;INCLUDE&apos;.
*           ignor only inside BEGIN OF ... END OF ...
            IF me_priv-inside_begin_end = 0.
*              RAISE RESUMABLE EXCEPTION TYPE statement_illegal.
            ENDIF.
          WHEN OTHERS.
*           syntax error or unsupported feature
*            RAISE RESUMABLE EXCEPTION TYPE statement_illegal.
        ENDCASE.
      ENDIF.
    ENDLOOP.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCAN_SOURCE_FOR_METHOD_IMPLS" VERSION="1" LANGU="E" DESCRIPT="SCAN_SOURCE_FOR_METHOD_IMPLS" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCAN_SOURCE_FOR_METHOD_IMPLS" SCONAME="METHOD_IMPLS" VERSION="1" LANGU="E" DESCRIPT="METHOD_IMPLS" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SABOO_METHOD_IMPL_TAB"/>
   <source>method SCAN_SOURCE_FOR_METHOD_IMPLS.
*  importing source_tab  type saboo_sourt
*  changing  method_impls type saboo_method_impl_tab.

    DATA:
      token_re1            TYPE saboo_tokesx,
      token_re2            TYPE saboo_tokesx,
      token_re3            TYPE saboo_tokesx,
      state_rec            TYPE saboo_state,
      state_len            TYPE i,
      x1                   TYPE i,
      scope_rec            TYPE scope_rec_type,
      begin_row            TYPE i,
      begin_col            TYPE i,
      end_row              TYPE i,
      end_col              TYPE i,
      whole_lines_begin    TYPE i,
      whole_lines_end      TYPE i,
      source_line1         TYPE LINE OF saboo_sourt,
      source_line2         TYPE LINE OF saboo_sourt,
      method_impl          TYPE saboo_method_impl.

    me-&gt;reset( ).

*   main loop to fill all method implementation table
    LOOP AT me_priv-state_tab INTO state_rec.
*     no empty statements
      CHECK state_rec-from &lt;= state_rec-to.
*     look only at normal ABAP statements
      IF ( state_rec-type = &apos;K&apos; ).
        state_len = state_rec-to - state_rec-from + 1.
*       get the first three tokens, if available
        CLEAR: token_re1, token_re2, token_re3.
        x1 = state_rec-from.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
        x1 = x1 + 1.
        READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
        x1 = x1 + 1.
        READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*       look for CLASS X IMPLEMENTATION statement
        IF ( state_len = 3 ) AND ( token_re1-str = &apos;CLASS&apos; ) AND
           ( token_re3-str = &apos;IMPLEMENTATION&apos; ).
*         increase the nested scope
          me_priv-nested_sc = me_priv-nested_sc + 1.
          me_priv-clsname       = token_re2-str.
          me_priv-superclsname  = &apos;*** void ***&apos;.
          scope_rec-clsname      = me_priv-clsname.
          scope_rec-superclsname = me_priv-superclsname.
          scope_rec-exposure     = me_priv-exposure.
          INSERT scope_rec INTO me_priv-scope_sta INDEX 1.
          me_priv-exposure = 2. &quot; default inside new definition PUBLIC
*       look for ENDCLASS
        ELSEIF ( state_len = 1 ) AND ( token_re1-str = &apos;ENDCLASS&apos; ).
*         decrease the nested scope
          IF me_priv-nested_sc &gt; 0.
            READ TABLE me_priv-scope_sta INDEX 1 INTO scope_rec.
            me_priv-exposure = scope_rec-exposure.
            DELETE me_priv-scope_sta INDEX 1.
            IF me_priv-nested_sc = 1.
              me_priv-nested_sc = 0.
              me_priv-clsname      = &apos;*** void ***&apos;.
              me_priv-superclsname = &apos;*** void ***&apos;.
            ELSE.
              SUBTRACT 1 FROM me_priv-nested_sc.
              READ TABLE me_priv-scope_sta INDEX 1 INTO scope_rec.
              me_priv-clsname      = scope_rec-clsname.
              me_priv-superclsname = scope_rec-superclsname.
            ENDIF.
          ENDIF.
*       look whether we are already inside definition
        ELSEIF me_priv-nested_sc &gt; 0.

*         find token ENDMETHOD or METHOD with misssing ENDMETHOD
          IF &apos;ENDMETHOD&apos; = token_re1-str OR
             ( &apos;METHOD&apos; = token_re1-str AND me_priv-cmpname  &lt;&gt; &apos;*** void ***&apos; ).
*           find ENDMETHOD statement
*           calculate end point in source and count whole lines
            end_row = token_re1-row.
            end_col = token_re1-col.
            whole_lines_begin = begin_row + 1.
            whole_lines_end    = end_row - 1.
*           fill wa for p_method_impls
            CLEAR: method_impl.
            method_impl-mtdkey-clsname = me_priv-clsname.
            method_impl-mtdkey-cpdname = me_priv-cmpname.
*           method source not empty ?
            IF ( begin_row &lt;&gt; end_row ) OR ( begin_col &lt;&gt; end_col ).
*             method source in one line ?
              IF ( begin_row = end_row ).
*               append one line
                x1 = end_col - begin_col.
                IF x1 &gt; 0.
                  READ TABLE me_priv-sourc_tab INTO source_line1 INDEX begin_row.
                  source_line2 = source_line1+begin_col(x1).
                  APPEND source_line2 TO method_impl-implementation.
                ENDIF.
*             method source in more than one line
              ELSE.
*               append first line
                IF begin_col &lt; const-max_line_size.
                  READ TABLE me_priv-sourc_tab INTO source_line1 INDEX begin_row.
                  source_line2 = source_line1+begin_col.
                  APPEND source_line2 TO method_impl-implementation.
                ENDIF.
*               append whole lines
                IF whole_lines_begin &lt;= whole_lines_end.
                  APPEND LINES OF me_priv-sourc_tab
                    FROM whole_lines_begin TO whole_lines_end
                    TO method_impl-implementation.
                ENDIF.
*               append last line
                IF end_col &gt; 0.
                  READ TABLE me_priv-sourc_tab INTO source_line1 INDEX end_row.
                  source_line2 = source_line1+0(end_col).
                  APPEND source_line2 TO method_impl-implementation.
                ENDIF.
              ENDIF.
            ENDIF.
*           append method to result
            APPEND method_impl TO method_impls.
*           reset indicator
            CLEAR: begin_row, end_row, begin_col, end_col.
            me_priv-cmpname  = &apos;*** void ***&apos;.
          ENDIF.

*         find token METHOD
          IF &apos;METHOD&apos; = token_re1-str.
*           find METHOD &apos;name&apos; statement
*           get method name and calculate start point in source
            me_priv-cmpname = token_re2-str.
            begin_row = state_rec-trow.
            begin_col = state_rec-tcol + 1.
          ENDIF.

        ENDIF.
      ENDIF.
    ENDLOOP.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SOURCE_TAB_TO_CHAR" VERSION="1" LANGU="E" DESCRIPT="SOURCE_TAB_TO_CHAR" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SOURCE_TAB_TO_CHAR" SCONAME="TYPSR_REC" VERSION="1" LANGU="E" DESCRIPT="TYPSR_REC" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_TYPSR"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SOURCE_TAB_TO_CHAR" SCONAME="CHAR" VERSION="1" LANGU="E" DESCRIPT="CHAR" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="C"/>
   <source>method SOURCE_TAB_TO_CHAR.
* importing typsr_rec type saboo_typsr changing char type c.

    DATA:
      len TYPE i,
      from_line TYPE i,
      to_line   TYPE i.

    FIELD-SYMBOLS:
      &lt;line&gt; TYPE c.

    ASSERT typsr_rec-begin_row &lt;= typsr_rec-end_row.

    IF typsr_rec-begin_row = typsr_rec-end_row.
      READ TABLE me_priv-sourc_tab ASSIGNING &lt;line&gt; INDEX typsr_rec-end_row.
      ASSERT sy-subrc IS INITIAL.
      len = typsr_rec-end_col - typsr_rec-begin_col + 1.
      CONCATENATE char &lt;line&gt;+typsr_rec-begin_col(len) cl_abap_char_utilities=&gt;cr_lf INTO char.
    ELSE.
      READ TABLE me_priv-sourc_tab ASSIGNING &lt;line&gt; INDEX typsr_rec-begin_row.
      ASSERT sy-subrc IS INITIAL.
      CONCATENATE &lt;line&gt;+typsr_rec-begin_col(*) cl_abap_char_utilities=&gt;cr_lf INTO char.

      from_line = typsr_rec-begin_row + 1.
      to_line   = typsr_rec-end_row - 1.
      LOOP AT me_priv-sourc_tab ASSIGNING &lt;line&gt; FROM from_line TO to_line.
        CONCATENATE char &lt;line&gt; cl_abap_char_utilities=&gt;cr_lf INTO char.
      ENDLOOP.

      IF typsr_rec-begin_row &lt; typsr_rec-end_row.
        READ TABLE me_priv-sourc_tab ASSIGNING &lt;line&gt; INDEX typsr_rec-end_row.
        ASSERT sy-subrc IS INITIAL.
        len = typsr_rec-end_col + 1.
        CONCATENATE char &lt;line&gt;(len) cl_abap_char_utilities=&gt;cr_lf INTO char.
      ENDIF.
    ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_EPARA" VERSION="1" LANGU="E" DESCRIPT="WRITE_EPARA" EXPOSURE="0" STATE="1" EDITORDER="21 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_EPARA" SCONAME="PARDECLTYP" VERSION="1" LANGU="E" DESCRIPT="PARDECLTYP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="N"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_EPARA" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_EPARA" SCONAME="CURRE_POS" VERSION="1" LANGU="E" DESCRIPT="CURRE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_EPARA" SCONAME="EPARA_TAB" VERSION="1" LANGU="E" DESCRIPT="EPARA_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_EPART"/>
   <source>method WRITE_EPARA.
*   importing value(pardecltyp) type n
*             state_end          type i
*   changing  curre_pos          type i
*             epara_tab          type saboo_epart.
    DATA:
      epara_rec   TYPE saboo_epara,
      token_re1   TYPE saboo_tokesx,
      token_re2   TYPE saboo_tokesx,
      token_re3   TYPE saboo_tokesx,
      x1          TYPE i,
      list_end    TYPE c,
      string1     TYPE string,
      string2     TYPE string.

    DO.
      x1 = curre_pos + 2.
*   do we have enough tokens left for a parameter
      IF x1 &gt; state_end.
        EXIT.
      ENDIF.
      CLEAR: token_re1, token_re2, token_re3, epara_rec, list_end.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX curre_pos.
      x1 = curre_pos + 1.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      x1 = curre_pos + 2.
      READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*   ? stop token, because of ABAP syntax check
      CASE token_re1-str.
        WHEN &apos;EXPORTING&apos;.
          IF pardecltyp &lt; 1.
            list_end = &apos;X&apos;.
          ENDIF.
      ENDCASE.
*   stop word =&gt; next parameter section
      IF list_end = &apos;X&apos;.
        EXIT.
      ENDIF.
*   got the name of the parameter
      CLEAR: string1, string2.
      SPLIT token_re1-str AT &apos;(&apos; INTO string1 string2.
      IF string2 = &apos;&apos;.
*     default is call by value
        epara_rec-sconame    = string1.
*      epara_rec-parpasstyp = 0.
      ELSE.
        CASE string1.
*       ? call by value
          WHEN &apos;VALUE&apos;.
            SPLIT string2 AT &apos;)&apos; INTO string1 string2.
            epara_rec-sconame    = string1.
*          epara_rec-parpasstyp = 0.
*       ? call by reference (but until now only call by value is valid)
          WHEN &apos;REFERENCE&apos;.
            SPLIT string2 AT &apos;)&apos; INTO string1 string2.
            epara_rec-sconame    = string1.
*          epara_rec-parpasstyp = 1.
*       unknown =&gt; default call by value
          WHEN OTHERS.
            SPLIT string2 AT &apos;)&apos; INTO string1 string2.
            epara_rec-sconame    = string1.
*          epara_rec-parpasstyp = 0.
        ENDCASE.
      ENDIF.
*   set type of parameter (e.g. IMPORTING, EXPORTING ...)
*   epara_rec-pardecltyp = pardecltyp. &quot; until now only EXPORTING
*   look for type
      CASE token_re2-str.
*     ? x LIKE y
        WHEN &apos;LIKE&apos;.
          CLEAR: token_re1, token_re2, token_re3.
          x1 = curre_pos + 2.
          IF ( x1 &lt;= state_end ).
            READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
            x1 = curre_pos + 3.
            IF ( x1 &lt;= state_end ).
              READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
              x1 = curre_pos + 4.
              IF ( x1 &lt;= state_end ).
                READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
              ENDIF.
            ENDIF.
          ENDIF.
          IF token_re1-type = sana_tok_word AND token_re2-type = sana_tok_word.
*       ? x LIKE REF TO y ... (using LIKE and concatenate REF TO to type)
            IF ( token_re1-str = &apos;REF&apos; ) AND ( token_re2-str = &apos;TO&apos; ).
              epara_rec-typtype = 0.
              CONCATENATE token_re1-str token_re2-str token_re3-str
                INTO epara_rec-type SEPARATED BY space.
              curre_pos = curre_pos + 5.
*       ? x LIKE LINE OF y ... (using LIKE and concatenate LINE OF to type)
            ELSEIF ( token_re1-str = &apos;LINE&apos; ) AND ( token_re2-str = &apos;OF&apos; ).
              epara_rec-typtype = 0.
              CONCATENATE token_re1-str token_re2-str token_re3-str
                INTO epara_rec-type SEPARATED BY space.
              curre_pos = curre_pos + 5.
            ELSE.
*           some unknown token string
              &quot;raise exception type statement_illegal.
            ENDIF.
*       ? x type y ...
          ELSE.
            epara_rec-typtype = 0.
            epara_rec-type    = token_re1-str.
            curre_pos         = curre_pos + 3.
          ENDIF.
*     ? x TYPE ...
        WHEN &apos;TYPE&apos;.
          CLEAR: token_re1, token_re2, token_re3.
          x1 = curre_pos + 2.
          IF ( x1 &lt;= state_end ).
            READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
            x1 = curre_pos + 3.
            IF ( x1 &lt;= state_end ).
              READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
              x1 = curre_pos + 4.
              IF ( x1 &lt;= state_end ).
                READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
              ENDIF.
            ENDIF.
          ENDIF.
          IF token_re1-type = sana_tok_word AND token_re2-type = sana_tok_word.
*       ? x TYPE REF TO y ...
            IF ( token_re1-str = &apos;REF&apos; ) AND ( token_re2-str = &apos;TO&apos; ).
              epara_rec-typtype = 3.
              epara_rec-type    = token_re3-str.
              curre_pos = curre_pos + 5.
*       ? x TYPE LINE OF y ...
            ELSEIF ( token_re1-str = &apos;LINE&apos; ) AND ( token_re2-str = &apos;OF&apos; ).
              epara_rec-typtype = 1.
              CONCATENATE token_re1-str token_re2-str token_re3-str
                INTO epara_rec-type SEPARATED BY space.
              curre_pos = curre_pos + 5.
*       ? x TYPE ANY/STANDARD/HASHED/INEX/SOETED TABLE
            ELSEIF ( ( token_re1-str = &apos;ANY&apos; )      OR
                     ( token_re1-str = &apos;STANDARD&apos; ) OR
                     ( token_re1-str = &apos;HASHED&apos; )   OR
                     ( token_re1-str = &apos;INDEX&apos; )    OR
                     ( token_re1-str = &apos;SORTED&apos; ) ) AND
                   ( token_re2-str = &apos;TABLE&apos; ).
              epara_rec-typtype = 1.
              CONCATENATE token_re1-str token_re2-str
                INTO epara_rec-type SEPARATED BY space.
              curre_pos = curre_pos + 4.
            ELSE.
*           some unknown token string
              &quot;raise exception type statement_illegal.
            ENDIF.
*       ? x type y ...
          ELSE.
            epara_rec-typtype = 1.
            epara_rec-type    = token_re1-str.
            curre_pos         = curre_pos + 3.
          ENDIF.
*     no type
        WHEN OTHERS.
          list_end = &apos;X&apos;.
      ENDCASE.
*   no type =&gt; no parameter
      IF list_end = &apos;X&apos;.
        EXIT.
      ENDIF.
*   defaults for addition data
      epara_rec-paroptionl = &apos; &apos;.
      epara_rec-parvalue   = &apos;&apos;.
*   look for additions
      IF curre_pos &lt;= state_end.
        CLEAR: token_re1, token_re2.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX curre_pos.
        x1 = curre_pos + 1.
        READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
        CASE token_re1-str.
*       ? OPTIONAL
          WHEN &apos;OPTIONAL&apos;.
            epara_rec-paroptionl = &apos;X&apos;.
            curre_pos = curre_pos + 1.
*       ? DEFAULT
          WHEN &apos;DEFAULT&apos;.
            epara_rec-paroptionl = &apos; &apos;.           &quot;MS 20070423
            epara_rec-parvalue   = token_re2-str.
            curre_pos            = curre_pos + 2.
        ENDCASE.
      ENDIF.
*   fill global record and append it
      epara_rec-clsname    = me_priv-clsname.
      epara_rec-cmpname    = me_priv-cmpname.
      epara_rec-version    = me_priv-version.
      epara_rec-langu      = me_priv-langu.
      epara_rec-editorder  = me_priv-editor_order. ADD 1 TO me_priv-editor_order.
      APPEND epara_rec TO epara_tab.
    ENDDO.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_MPARA" VERSION="1" LANGU="E" DESCRIPT="WRITE_MPARA" EXPOSURE="0" STATE="1" EDITORDER="20 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_MPARA" SCONAME="PARDECLTYP" VERSION="1" LANGU="E" DESCRIPT="PARDECLTYP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="N"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_MPARA" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_MPARA" SCONAME="CURRE_POS" VERSION="1" LANGU="E" DESCRIPT="CURRE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_MPARA" SCONAME="MPARA_TAB" VERSION="1" LANGU="E" DESCRIPT="MPARA_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_MPART"/>
   <source>method WRITE_MPARA.
*   importing value(pardecltyp) type n
*             state_end         type i
*   changing  curre_pos         type i
*             mpara_tab         type saboo_mpart.

    DATA:
      mpara_rec   TYPE saboo_mpara,
      token_re1   TYPE saboo_tokesx,
      token_re2   TYPE saboo_tokesx,
      token_re3   TYPE saboo_tokesx,
      x1          TYPE i,
      list_end    TYPE c,
      string1(30) TYPE c,
      string2(30) TYPE c.

    FIELD-SYMBOLS:
      &lt;fs&gt; TYPE saboo_mpara.

    DO.
      x1 = curre_pos + 2.
*   do we have enough tokens left for a parameter
      IF x1 &gt; state_end.
        EXIT.
      ENDIF.
      CLEAR: token_re1, token_re2, token_re3, mpara_rec, list_end.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX curre_pos.
      x1 = curre_pos + 1.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      x1 = curre_pos + 2.
      READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*   ? stop token, because of ABAP syntax check
      CASE token_re1-str.
        WHEN &apos;EXPORTING&apos;.
          IF pardecltyp &lt; 1.
            list_end = &apos;X&apos;.
          ENDIF.
        WHEN &apos;CHANGING&apos;.
          IF pardecltyp &lt; 2.
            list_end = &apos;X&apos;.
          ENDIF.
        WHEN &apos;RETURNING&apos;.
          IF pardecltyp &lt; 3.
            list_end = &apos;X&apos;.
          ENDIF.
        WHEN &apos;PREFERRED&apos;.
*       addition PREFERRED PARAMETER x for importing parameter
          IF token_re2-str = &apos;PARAMETER&apos; AND pardecltyp = 0.
            READ TABLE mpara_tab                            &quot;#EC *
              ASSIGNING &lt;fs&gt;
              WITH KEY clsname = me_priv-clsname
                       cmpname = me_priv-cmpname(30)
                       sconame = token_re3-str. &quot;EC *
            IF sy-subrc = 0.
              &lt;fs&gt;-parpreferd = &apos;X&apos;.
            ENDIF.
            curre_pos = curre_pos + 3.
            list_end = &apos;X&apos;.
          ENDIF.
      ENDCASE.
*   stop word =&gt; next parameter section
      IF list_end = &apos;X&apos;.
        EXIT.
      ENDIF.
*   got the name of the parameter
      CLEAR: string1, string2.
      SPLIT token_re1-str AT &apos;(&apos; INTO string1 string2.
      IF string2 = &apos;&apos;.
*     default is call by reference
        mpara_rec-sconame    = string1.
        mpara_rec-parpasstyp = 1.
      ELSE.
        CASE string1.
*       ? call by value
          WHEN &apos;VALUE&apos;.
            SPLIT string2 AT &apos;)&apos; INTO string1 string2.
            mpara_rec-sconame    = string1.
            mpara_rec-parpasstyp = 0.
*       ? call by reference
          WHEN &apos;REFERENCE&apos;.
            SPLIT string2 AT &apos;)&apos; INTO string1 string2.
            mpara_rec-sconame    = string1.
            mpara_rec-parpasstyp = 1.
*       unknown =&gt; default call by reference
          WHEN OTHERS.
            SPLIT string2 AT &apos;)&apos; INTO string1 string2.
            mpara_rec-sconame    = string1.
            mpara_rec-parpasstyp = 0.
        ENDCASE.
      ENDIF.
*   set type of parameter (e.g. IMPORTING, EXPORTING ...)
      mpara_rec-pardecltyp = pardecltyp.
*   look for type
      CASE token_re2-str.
*     ? x LIKE y
        WHEN &apos;LIKE&apos;.
          CLEAR: token_re1, token_re2, token_re3.
          x1 = curre_pos + 2.
          IF ( x1 &lt;= state_end ).
            READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
            x1 = curre_pos + 3.
            IF ( x1 &lt;= state_end ).
              READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
              x1 = curre_pos + 4.
              IF ( x1 &lt;= state_end ).
                READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
              ENDIF.
            ENDIF.
          ENDIF.
          IF token_re1-type = sana_tok_word AND token_re2-type = sana_tok_word.
*       ? x LIKE REF TO y ... (using LIKE and concatenate REF TO to type)
            IF ( token_re1-str = &apos;REF&apos; ) AND ( token_re2-str = &apos;TO&apos; ).
              mpara_rec-typtype = 0.
              CONCATENATE token_re1-str token_re2-str token_re3-str
                INTO mpara_rec-type SEPARATED BY space.
              curre_pos = curre_pos + 5.
*       ? x TYPE LINE OF y ... (using LIKE and concatenate LINE OF to type)
            ELSEIF ( token_re1-str = &apos;LINE&apos; ) AND ( token_re2-str = &apos;OF&apos; ).
              mpara_rec-typtype = 0.
              CONCATENATE token_re1-str token_re2-str token_re3-str
                INTO mpara_rec-type SEPARATED BY space.
              curre_pos = curre_pos + 5.
            ELSE.
*           some unknown token string
              &quot;raise exception type statement_illegal.
            ENDIF.
*       ? x type y ...
          ELSE.
            mpara_rec-typtype = 0.
            mpara_rec-type    = token_re1-str.
            curre_pos         = curre_pos + 3.
          ENDIF.
*     ? x TYPE ...
        WHEN &apos;TYPE&apos;.
          CLEAR: token_re1, token_re2, token_re3.
          x1 = curre_pos + 2.
          IF ( x1 &lt;= state_end ).
            READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
            x1 = curre_pos + 3.
            IF ( x1 &lt;= state_end ).
              READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
              x1 = curre_pos + 4.
              IF ( x1 &lt;= state_end ).
                READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
              ENDIF.
            ENDIF.
          ENDIF.
          IF token_re1-type = sana_tok_word AND token_re2-type = sana_tok_word.
*       ? x TYPE REF TO y ...
            IF ( token_re1-str = &apos;REF&apos; ) AND ( token_re2-str = &apos;TO&apos; ).
              mpara_rec-typtype = 3.
              mpara_rec-type    = token_re3-str.
              curre_pos = curre_pos + 5.
*       ? x TYPE LINE OF y ...
            ELSEIF ( token_re1-str = &apos;LINE&apos; ) AND ( token_re2-str = &apos;OF&apos; ).
              mpara_rec-typtype = 1.
              CONCATENATE token_re1-str token_re2-str token_re3-str
                INTO mpara_rec-type SEPARATED BY space.
              curre_pos = curre_pos + 5.
*       ? x TYPE ANY/STANDARD/HASHED/INEX/SOETED TABLE
            ELSEIF ( ( token_re1-str = &apos;ANY&apos; )      OR
                     ( token_re1-str = &apos;STANDARD&apos; ) OR
                     ( token_re1-str = &apos;HASHED&apos; )   OR
                     ( token_re1-str = &apos;INDEX&apos; )    OR
                     ( token_re1-str = &apos;SORTED&apos; ) ) AND
                   ( token_re2-str = &apos;TABLE&apos; ).
              mpara_rec-typtype = 1.
              CONCATENATE token_re1-str token_re2-str
                INTO mpara_rec-type SEPARATED BY space.
              curre_pos = curre_pos + 4.
            ELSE.
*           some unknown token string
              &quot;raise exception type statement_illegal.
            ENDIF.
*       ? x type y ...
          ELSE.
            mpara_rec-typtype = 1.
            mpara_rec-type    = token_re1-str.
            curre_pos         = curre_pos + 3.
          ENDIF.
*     no type
        WHEN OTHERS.
          list_end = &apos;X&apos;.
      ENDCASE.
*   no type =&gt; no parameter
      IF list_end = &apos;X&apos;.
        EXIT.
      ENDIF.
*   defaults for addition data
      mpara_rec-paroptionl = &apos; &apos;.
      mpara_rec-parvalue   = &apos;&apos;.
*   look for additions
      IF curre_pos &lt;= state_end.
        CLEAR: token_re1, token_re2.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX curre_pos.
        x1 = curre_pos + 1.
        READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
*     only if token is word and not identifier
        IF token_re1-type = sana_tok_word.
          CASE token_re1-str.
*       ? OPTIONAL
            WHEN &apos;OPTIONAL&apos;.
              mpara_rec-paroptionl = &apos;X&apos;.
              curre_pos            = curre_pos + 1.
*       ? DEFAULT
            WHEN &apos;DEFAULT&apos;.
              mpara_rec-paroptionl = &apos; &apos;.           &quot;MS 20070423
              mpara_rec-parvalue   = token_re2-str.
              curre_pos            = curre_pos + 2.
          ENDCASE.
        ENDIF.
      ENDIF.
*   fill global record and append it
      mpara_rec-clsname    = me_priv-clsname.
      mpara_rec-cmpname    = me_priv-cmpname.
      mpara_rec-version    = me_priv-version.
      mpara_rec-langu      = me_priv-langu.
      mpara_rec-mtdtype    = me_priv-mtdtype.
      mpara_rec-editorder  = me_priv-editor_order. ADD 1 TO me_priv-editor_order.
      APPEND mpara_rec TO mpara_tab.
    ENDDO.
endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_PACKAGE" VERSION="1" LANGU="E" DESCRIPT="Pakage" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_WB_PACKAGE" REFCLSNAME="ZIF_WB_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>*&quot;* use this source file for your ABAP unit test classes</localTestClasses>
  <attribute CLSNAME="ZCL_WB_PACKAGE" CMPNAME="DEVCLASS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TDEVC-DEVCLASS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_PACKAGE" CMPNAME="LANGU" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TDEVCT-SPRAS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_PACKAGE" CMPNAME="TDEVC" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TDEVC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_WB_PACKAGE" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.

    CALL FUNCTION &apos;TR_DEVCLASS_GET&apos;
      EXPORTING
        iv_devclass        = me-&gt;devclass      &quot; Package
        iv_langu           = me-&gt;langu    &quot; Language for short text
      IMPORTING
        es_tdevc           = me-&gt;tdevc    &quot; Read package
      EXCEPTIONS
        devclass_not_found = 1
        OTHERS             = 2.
    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE zcx_wb_object_dont_exist.
    ENDIF.

  ENDMETHOD.                    &quot;zif_wb_object~load</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_PACKAGE" CPDNAME="ZIF_WB_OBJECT~TO_STRING">
   <source>METHOD zif_wb_object~to_string.

    CONCATENATE:
          &apos;Package:&apos;
          me-&gt;devclass
          &apos;-&apos;
          me-&gt;tdevc-ctext
      INTO re_string
      SEPARATED BY &apos; &apos;.

  ENDMETHOD.                    &quot;zif_wb_object~to_string</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_PACKAGE" CPDNAME="ZIF_WB_OBJECT~WRITE">
   <source>METHOD zif_wb_object~write.

  ENDMETHOD.                    &quot;zif_wb_object~write</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_PACKAGE" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_PACKAGE" CMPNAME="CONSTRUCTOR" SCONAME="IM_DEVCLASS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TDEVC-DEVCLASS"/>
   <parameter CLSNAME="ZCL_WB_PACKAGE" CMPNAME="CONSTRUCTOR" SCONAME="IM_LANGU" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TDEVCT-SPRAS" PAROPTIONL="X"/>
   <source>METHOD constructor.
    me-&gt;devclass = im_devclass.

    me-&gt;langu = im_langu.
    IF im_langu IS NOT SUPPLIED.
      me-&gt;langu = sy-langu.
    ENDIF.

  ENDMETHOD.                    &quot;constructor</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_LOCK_OBJECT" VERSION="1" LANGU="E" DESCRIPT="Lock Object" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <types CLSNAME="ZCL_WB_LOCK_OBJECT" CMPNAME="TY_TT_DD26E" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="17 " SRCCOLUMN1="11 " SRCROW2="17 " SRCCOLUMN2="50 " TYPESRC_LENG="42 " TYPESRC="ty_tt_dd26e TYPE STANDARD TABLE OF dd26e
"/>
  <types CLSNAME="ZCL_WB_LOCK_OBJECT" CMPNAME="TY_TT_DD27P" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="18 " SRCCOLUMN1="11 " SRCROW2="18 " SRCCOLUMN2="50 " TYPESRC_LENG="42 " TYPESRC="ty_tt_dd27p TYPE STANDARD TABLE OF dd27p
"/>
  <types CLSNAME="ZCL_WB_LOCK_OBJECT" CMPNAME="TY_TT_DDENA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="19 " SRCCOLUMN1="11 " SRCROW2="19 " SRCCOLUMN2="50 " TYPESRC_LENG="42 " TYPESRC="ty_tt_ddena TYPE STANDARD TABLE OF ddena
"/>
  <implementing CLSNAME="ZCL_WB_LOCK_OBJECT" REFCLSNAME="ZIF_WB_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>*&quot;* use this source file for your ABAP unit test classes</localTestClasses>
  <attribute CLSNAME="ZCL_WB_LOCK_OBJECT" CMPNAME="DD25V_WA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DD25V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_LOCK_OBJECT" CMPNAME="DD26E_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD26E" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_LOCK_OBJECT" CMPNAME="DD27P_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD27P" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_LOCK_OBJECT" CMPNAME="DDENA_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DDENA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_LOCK_OBJECT" CMPNAME="GOTSTATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDGOTSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_LOCK_OBJECT" CMPNAME="LANGU" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SY-LANGU" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_LOCK_OBJECT" CMPNAME="NAME" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_LOCK_OBJECT" CMPNAME="STATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_WB_LOCK_OBJECT" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.

    CALL FUNCTION &apos;DDIF_ENQU_GET&apos;
      EXPORTING
        name          = me-&gt;name     &quot; Name of the Lock Object to be Read
        state         = me-&gt;state    &quot; Read Status of the Lock Object
        langu         = me-&gt;langu    &quot; Language in which Texts are Read
      IMPORTING
        gotstate      = me-&gt;gotstate     &quot; Status in which Reading took Place
        dd25v_wa      = me-&gt;dd25v_wa    &quot; Header of the Lock Object
      TABLES
        dd26e_tab     = me-&gt;dd26e_tab    &quot; Base Tables of the Lock Object
        dd27p_tab     = me-&gt;dd27p_tab    &quot; Lock Parameter of the Lock Object
        ddena_tab     = me-&gt;ddena_tab    &quot; Lock Arguments of the Lock Object
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.

    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE zcx_wb_object_dont_exist.
    ENDIF.

  ENDMETHOD.                    &quot;zif_wb_object~LOAD</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_LOCK_OBJECT" CPDNAME="ZIF_WB_OBJECT~TO_STRING">
   <source>METHOD zif_wb_object~to_string.

    CONCATENATE:
          &apos;Lock Object:&apos;
          me-&gt;name
          &apos;-&apos;
          me-&gt;dd25v_wa-ddtext
      INTO re_string
      SEPARATED BY &apos; &apos;.

  ENDMETHOD.                    &quot;zif_wb_object~to_string</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_LOCK_OBJECT" CPDNAME="ZIF_WB_OBJECT~WRITE">
   <source>METHOD zif_wb_object~write.

  ENDMETHOD.                    &quot;zif_wb_object~write</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_LOCK_OBJECT" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_LOCK_OBJECT" CMPNAME="CONSTRUCTOR" SCONAME="IM_NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJNAME"/>
   <parameter CLSNAME="ZCL_WB_LOCK_OBJECT" CMPNAME="CONSTRUCTOR" SCONAME="IM_STATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJSTATE" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_WB_LOCK_OBJECT" CMPNAME="CONSTRUCTOR" SCONAME="IM_LANGU" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYST-LANGU" PAROPTIONL="X"/>
   <source>METHOD constructor.
    me-&gt;name = im_name.

    me-&gt;state = im_state.
    IF im_state IS NOT SUPPLIED.
      me-&gt;state = &apos;A&apos;.
    ENDIF.

    me-&gt;langu = im_langu.
    IF im_langu IS NOT SUPPLIED.
      me-&gt;langu = space.
    ENDIF.

  ENDMETHOD.                    &quot;constructor</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_INTERFACE_LOCAL" VERSION="1" LANGU="E" DESCRIPT="Local Interface" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZCL_WB_INTERFACE">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE_LOCAL" TYPEGROUP="SABOO" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE_LOCAL" TYPEGROUP="SEOK" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE_LOCAL" TYPEGROUP="SEOO" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE_LOCAL" TYPEGROUP="SEOR" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE_LOCAL" TYPEGROUP="SEOS" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE_LOCAL" TYPEGROUP="SEOT" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>SABOO</forwardDeclaration>
  <forwardDeclaration>SEOK</forwardDeclaration>
  <forwardDeclaration>SEOO</forwardDeclaration>
  <forwardDeclaration>SEOR</forwardDeclaration>
  <forwardDeclaration>SEOS</forwardDeclaration>
  <forwardDeclaration>SEOT</forwardDeclaration>
  <attribute CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="INTERF_NAME" VERSION="1" LANGU="E" DESCRIPT="Object Type Name" EXPOSURE="1" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="VSEOINTERF-CLSNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="PROGRAM" VERSION="1" LANGU="E" DESCRIPT="ABAP Program Name" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="PROGRAMM" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="T_VSEO_TABS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SABOO_VSEOT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCL_WB_INTERFACE_LOCAL" REFCLSNAME="ZCL_WB_INTERFACE" VERSION="1" STATE="1">
   <redefinition CLSNAME="ZCL_WB_INTERFACE_LOCAL" REFCLSNAME="ZCL_WB_INTERFACE" VERSION="1" MTDNAME="ZIF_WB_OBJECT~LOAD" EXPOSURE="0"/>
   <redefinition CLSNAME="ZCL_WB_INTERFACE_LOCAL" REFCLSNAME="ZCL_WB_INTERFACE" VERSION="1" MTDNAME="ZIF_WB_OBJECT~TO_STRING" EXPOSURE="0"/>
  </inheritance>
  <interfaceMethod CLSNAME="ZCL_WB_INTERFACE_LOCAL" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.

    DATA lt_source_code TYPE saboo_sourt.
    DATA r_wb_scanner TYPE REF TO zcl_wb_scanner_objects.
    DATA lwa_interface LIKE LINE OF me-&gt;t_vseo_tabs-inter_tab.

    READ REPORT me-&gt;program INTO lt_source_code.
    zcl_wb_scanner_objects=&gt;create(
      IMPORTING
        scanner = r_wb_scanner
      CHANGING
        sourc_tab = lt_source_code  ).

    me-&gt;t_vseo_tabs = r_wb_scanner-&gt;scan_source( ).

    READ TABLE me-&gt;t_vseo_tabs-inter_tab INTO lwa_interface WITH KEY clsname = me-&gt;interf_name.
    IF sy-subrc IS INITIAL.
      me-&gt;move_vseo_tabs_to_att(
      EXPORTING
        im_vseo_tabs = me-&gt;t_vseo_tabs
      ).
    ELSE.
      RAISE EXCEPTION TYPE zcx_wb_class_dont_exist.
    ENDIF.
  ENDMETHOD.                    &quot;zif_wb_object~load</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_INTERFACE_LOCAL" CPDNAME="ZIF_WB_OBJECT~TO_STRING">
   <source>METHOD zif_wb_object~to_string.

    CONCATENATE:
          &apos;Program:&apos;
          me-&gt;program
          &apos; - Local Interface:&apos;
          me-&gt;interface-clsname
          &apos;-&apos;
          me-&gt;interface-descript
      INTO re_string
      SEPARATED BY &apos; &apos;.

  ENDMETHOD.                    &quot;zif_wb_object~TO_STRING</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_PROGRAM" VERSION="1" LANGU="E" DESCRIPT="ABAP Program Name" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="PROGRAMM"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_INTERFACE_NAME" VERSION="1" LANGU="E" DESCRIPT="Object Type Name" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="VSEOINTERF-CLSNAME"/>
   <source>METHOD constructor.
    super-&gt;constructor( ).
    me-&gt;program = im_program.
    me-&gt;interf_name = im_interface_name.

  ENDMETHOD.                    &quot;CONSTRUCTOR</source>
  </method>
  <method CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="LOAD_ALL_INTERFACES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="LOAD_ALL_INTERFACES" SCONAME="IM_PROGRAM" VERSION="1" LANGU="E" DESCRIPT="ABAP Program Name" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="PROGRAMM"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="LOAD_ALL_INTERFACES" SCONAME="RE_T_R_INTERFACES" VERSION="1" LANGU="E" DESCRIPT="Table of WB local interfaces" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTT_WB_INTERFACE_LOCAL"/>
   <exception CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="LOAD_ALL_INTERFACES" SCONAME="ZCX_WB_REPORT_WITHOUT_INTER" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="LOAD_ALL_INTERFACES" SCONAME="ZCX_WB_REPORT_DONT_EXIST" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="2 "/>
   <source>METHOD load_all_interfaces.

    DATA r_wb_scanner TYPE REF TO zcl_wb_scanner_objects.
    DATA t_source_code TYPE saboo_sourt.
    DATA lwa_vseo_tabs TYPE saboo_vseot .
    DATA lwa_interface LIKE LINE OF lwa_vseo_tabs-inter_tab.

    READ REPORT im_program INTO t_source_code.
    IF sy-subrc IS NOT INITIAL.
      &quot; If the report doesn&apos;t exist or cannot be read, the same exception is thrown
      RAISE EXCEPTION TYPE zcx_wb_report_dont_exist.
    ENDIF.

    zcl_wb_scanner_objects=&gt;create(
      IMPORTING
        scanner = r_wb_scanner
      CHANGING
        sourc_tab = t_source_code  ).

    lwa_vseo_tabs = r_wb_scanner-&gt;scan_source( ).

    IF lwa_vseo_tabs-inter_tab IS INITIAL.
      RAISE EXCEPTION TYPE zcx_wb_report_without_inter.
    ENDIF.

    DATA lr_local_interface TYPE REF TO zcl_wb_interface_local.
    LOOP AT lwa_vseo_tabs-inter_tab INTO lwa_interface.

      CREATE OBJECT lr_local_interface
        EXPORTING
          im_program        = im_program
          im_interface_name = lwa_interface-clsname.

      lr_local_interface-&gt;move_vseo_tabs_to_att( im_vseo_tabs = lwa_vseo_tabs ).

      APPEND lr_local_interface TO re_t_r_interfaces.

    ENDLOOP.
  ENDMETHOD.                    &quot;load_all_interfaces</source>
  </method>
  <method CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="MOVE_VSEO_TABS_TO_ATT" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="MOVE_VSEO_TABS_TO_ATT" SCONAME="IM_VSEO_TABS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_VSEOT"/>
   <source>METHOD move_vseo_tabs_to_att.

* Class
    DATA lwa_vseointerf TYPE vseointerf.
    LOOP AT im_vseo_tabs-inter_tab INTO lwa_vseointerf
        WHERE clsname = me-&gt;interf_name.
      me-&gt;interface = lwa_vseointerf.
    ENDLOOP.

* Attributes
    DATA lwa_vseoattrib TYPE vseoattrib.
    LOOP AT im_vseo_tabs-attri_tab INTO lwa_vseoattrib
      WHERE clsname = me-&gt;interf_name.
      APPEND lwa_vseoattrib TO me-&gt;attributes.
    ENDLOOP.

* Methods
    DATA lwa_vseomethod TYPE vseomethod.
    LOOP AT im_vseo_tabs-metho_tab INTO lwa_vseomethod
      WHERE clsname = me-&gt;interf_name.
      APPEND lwa_vseomethod TO me-&gt;methods.
    ENDLOOP.

* Method parameters
*    DATA lwa_mpara_tab TYPE vseomepara.
*    LOOP AT im_vseo_tabs-mpara_tab INTO lwa_mpara_tab
*      WHERE clsname = me-&gt;class_name.
*      APPEND lwa_mpara_tab TO me-&gt;parameters.
*    ENDLOOP.

* Exceptions
    DATA lwa_mexce_tab TYPE vseoexcep.
    LOOP AT im_vseo_tabs-mexce_tab INTO lwa_mexce_tab
      WHERE clsname = me-&gt;interf_name.
      APPEND lwa_mexce_tab TO me-&gt;exceps.
    ENDLOOP.

* Interfaces
*    data lwa_vseoimplem type vseoimplem.
*    loop at im_vseo_tabs-iimpl_tab into lwa_vseoimplem
*      where clsname = me-&gt;interf_name.
*      append lwa_vseoimplem to me-&gt;implementings.
*    endloop.

* Types
    DATA lwa_vseotype TYPE vseotype.
    LOOP AT im_vseo_tabs-types_tab INTO lwa_vseotype
      WHERE clsname = me-&gt;interf_name.
      APPEND lwa_vseotype TO me-&gt;types.
    ENDLOOP.



  ENDMETHOD.                    &quot;MOVE_VSEO_TABS_TO_ATT</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_INTERFACE_GLOBAL" VERSION="1" LANGU="E" DESCRIPT="WB global interface" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZCL_WB_INTERFACE">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="ENHA_ACTION" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="IGNORE_SWITCHES" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="CHAR1" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="INTKEY" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOCLSKEY" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="READ_ACTIVE_ENHA" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="STATE" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="VERSION" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOVERSION" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="WITH_ENHANCEMENTS" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="WITH_MASTER_LANGUAGE" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCL_WB_INTERFACE_GLOBAL" REFCLSNAME="ZCL_WB_INTERFACE" VERSION="1" STATE="1">
   <redefinition CLSNAME="ZCL_WB_INTERFACE_GLOBAL" REFCLSNAME="ZCL_WB_INTERFACE" VERSION="1" MTDNAME="ZIF_WB_OBJECT~LOAD" EXPOSURE="2"/>
  </inheritance>
  <interfaceMethod CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.


    CALL FUNCTION &apos;SEO_INTERFACE_TYPEINFO_GET&apos;
      EXPORTING
        intkey                  = me-&gt;intkey
        version                 = me-&gt;version
        state                   = me-&gt;state
        with_master_language    = me-&gt;with_master_language
        with_enhancements       = me-&gt;with_enhancements
        read_active_enha        = me-&gt;read_active_enha
        enha_action             = me-&gt;enha_action
        ignore_switches         = me-&gt;ignore_switches
      IMPORTING
        interface               = me-&gt;interface
        attributes              = me-&gt;attributes
        methods                 = me-&gt;methods
        events                  = me-&gt;events
        parameters              = me-&gt;parameters
        exceps                  = me-&gt;exceps
        comprisings             = me-&gt;comprisings
        typepusages             = me-&gt;typepusages
        clsdeferrds             = me-&gt;clsdeferrds
        intdeferrds             = me-&gt;intdeferrds
        explore_comprisings     = me-&gt;explore_comprisings
        aliases                 = me-&gt;aliases
        types                   = me-&gt;types
        enhancement_methods     = me-&gt;enhancement_methods
        enhancement_attributes  = me-&gt;enhancement_attributes
        enhancement_events      = me-&gt;enhancement_events
        enhancement_comprisings = me-&gt;enhancement_comprisings
        enhancement_types       = me-&gt;enhancement_types
      EXCEPTIONS
        not_existing            = 1
        is_class                = 2
        model_only              = 3
        OTHERS                  = 4.


    CASE sy-subrc.
      WHEN 1.
        RAISE EXCEPTION TYPE zcx_wb_interface_dont_exist.
      WHEN 2.
        RAISE EXCEPTION TYPE zcx_wb_is_class.
      WHEN 3.
        RAISE EXCEPTION TYPE zcx_wb_interface_is_model_only.
    ENDCASE.

  ENDMETHOD.                    &quot;zif_wb_object~load</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_INTKEY" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCLSKEY"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_VERSION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOVERSION" PARVALUE="SEOC_VERSION_INACTIVE"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_STATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOSTATE" PARVALUE="&apos;1&apos;"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_WITH_MASTER_LANGUAGE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_WITH_ENHANCEMENTS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_READ_ACTIVE_ENHA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_ENHA_ACTION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_IGNORE_SWITCHES" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR1" PARVALUE="&apos;X&apos;"/>
   <source>METHOD constructor.

    super-&gt;constructor( ).

    me-&gt;intkey                = im_intkey.
    me-&gt;version               = im_version.
    me-&gt;state                 = im_state.
    me-&gt;with_master_language  = im_with_master_language.
    me-&gt;with_enhancements     = im_with_enhancements.
    me-&gt;read_active_enha      = im_read_active_enha.
    me-&gt;enha_action           = im_enha_action.
    me-&gt;ignore_switches       = im_ignore_switches.

  ENDMETHOD.                    &quot;CONSTRUCTOR</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_INTERFACE" VERSION="1" LANGU="E" DESCRIPT="Generic Interface" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_WB_INTERFACE" REFCLSNAME="ZIF_WB_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE" TYPEGROUP="SEOK" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE" TYPEGROUP="SEOO" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE" TYPEGROUP="SEOR" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE" TYPEGROUP="SEOS" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE" TYPEGROUP="SEOT" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>SEOK</forwardDeclaration>
  <forwardDeclaration>SEOO</forwardDeclaration>
  <forwardDeclaration>SEOR</forwardDeclaration>
  <forwardDeclaration>SEOS</forwardDeclaration>
  <forwardDeclaration>SEOT</forwardDeclaration>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="ALIASES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="12 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_ALIASES_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="ATTRIBUTES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_ATTRIBUTES_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="CLSDEFERRDS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="9 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOT_CLSDEFERRDS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="COMPRISINGS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOR_COMPRISINGS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="ENHANCEMENT_ATTRIBUTES" VERSION="1" LANGU="E" DESCRIPT="Table with attributes that were defined as enhancements" EXPOSURE="2" STATE="1" EDITORDER="15 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHCLASSTABATTRIB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="ENHANCEMENT_COMPRISINGS" VERSION="1" LANGU="E" DESCRIPT="Table with interfaces defines in interfaces as enhancement" EXPOSURE="2" STATE="1" EDITORDER="17 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHCLASSTABINTFCOMPRI" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="ENHANCEMENT_EVENTS" VERSION="1" LANGU="E" DESCRIPT="Table with events that were defined as enhancements" EXPOSURE="2" STATE="1" EDITORDER="16 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHCLASSTABEVENT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="ENHANCEMENT_METHODS" VERSION="1" LANGU="E" DESCRIPT="Table with header data from new enhancement methods" EXPOSURE="2" STATE="1" EDITORDER="14 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHMETH_TABHEADER" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="ENHANCEMENT_TYPES" VERSION="1" LANGU="E" DESCRIPT="Table with Types as Enhancements" EXPOSURE="2" STATE="1" EDITORDER="18 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHTYPE_TAB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="EVENTS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_EVENTS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="EXCEPS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOS_EXCEPTIONS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="EXPLORE_COMPRISINGS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="11 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOK_INT_TYPEINFOS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="INTDEFERRDS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="10 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOT_INTDEFERRDS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="INTERFACE" VERSION="1" LANGU="E" DESCRIPT="Generated Table for View" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="VSEOINTERF" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="METHODS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_METHODS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="PARAMETERS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOS_PARAMETERS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="TYPEPUSAGES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOT_TYPEPUSAGES_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="TYPES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="13 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_TYPES_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_WB_INTERFACE" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.
  ENDMETHOD.                    &quot;ZIF_WB_OBJECT~LOAD</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_INTERFACE" CPDNAME="ZIF_WB_OBJECT~TO_STRING">
   <source>METHOD zif_wb_object~to_string.

    CONCATENATE:
          &apos;Interface:&apos;
          me-&gt;interface-clsname
          &apos;-&apos;
          me-&gt;interface-descript
      INTO re_string
      SEPARATED BY &apos; &apos;.

  ENDMETHOD.                    &quot;zif_wb_object~to_string</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_INTERFACE" CPDNAME="ZIF_WB_OBJECT~WRITE">
   <source>METHOD zif_wb_object~write.
* This method is currently for demonstration purposes of the framework
* sooner or later it will be removed from here.
* DO NOT USE!

    WRITE:
        &apos;Interface:&apos;,
        me-&gt;interface-clsname,
        &apos; - &apos;,
        me-&gt;interface-descript.
    NEW-LINE.

* attributes
    DATA lwa_attributes TYPE vseoattrib.
    WRITE: &apos;Attributes&apos; COLOR 3. NEW-LINE.

    LOOP AT me-&gt;attributes INTO lwa_attributes.
      WRITE lwa_attributes-cmpname        . NEW-LINE.
    ENDLOOP.

    DATA lwa_method TYPE seoo_method_r.
    WRITE: &apos;Methods&apos; COLOR 3. NEW-LINE.
    LOOP AT me-&gt;methods INTO lwa_method.
      WRITE lwa_method-cmpname. NEW-LINE.
    ENDLOOP.
    ULINE.

  ENDMETHOD.                    &quot;ZIF_WB_OBJECT~WRITE</source>
  </interfaceMethod>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_INDEX" VERSION="1" LANGU="E" DESCRIPT="Database index" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <types CLSNAME="ZCL_WB_INDEX" CMPNAME="TY_TT_DD17V" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="12 " SRCCOLUMN1="9 " SRCROW2="12 " SRCCOLUMN2="48 " TYPESRC_LENG="42 " TYPESRC="TY_TT_DD17V TYPE STANDARD TABLE OF DD17V
"/>
  <implementing CLSNAME="ZCL_WB_INDEX" REFCLSNAME="ZIF_WB_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>*&quot;* use this source file for your ABAP unit test classes</localTestClasses>
  <attribute CLSNAME="ZCL_WB_INDEX" CMPNAME="DD12V_WA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DD12V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INDEX" CMPNAME="DD17V_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TT_DD17V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INDEX" CMPNAME="GOTSTATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDGOTSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INDEX" CMPNAME="ID" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJECTID" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INDEX" CMPNAME="LANGU" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SY-LANGU" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INDEX" CMPNAME="NAME" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INDEX" CMPNAME="STATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_WB_INDEX" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.
    CALL FUNCTION &apos;DDIF_INDX_GET&apos;
      EXPORTING
        name          = me-&gt;name     &quot; Name of the Table of the Index to be Read
        id            = me-&gt;id    &quot; Identification of the Index to be Read
        state         = me-&gt;state    &quot; Read Status of the Index
        langu         = me-&gt;langu    &quot; Language of the Text
      IMPORTING
        gotstate      = me-&gt;gotstate     &quot; Status in which Reading took Place
        dd12v_wa      = me-&gt;dd12v_wa    &quot; Header of the Index
      TABLES
        dd17v_tab     = me-&gt;dd17v_tab    &quot; Fields of the Index
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE zcx_wb_object_dont_exist.
    ENDIF.

  ENDMETHOD.                    &quot;zif_wb_object~LOAD</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_INDEX" CPDNAME="ZIF_WB_OBJECT~TO_STRING">
   <source>METHOD zif_wb_object~to_string.

  CONCATENATE:
        &apos;Index:&apos;
        me-&gt;name
        &apos;-&apos;
        me-&gt;dd12v_wa-ddtext
    INTO re_string
    SEPARATED BY &apos; &apos;.

  ENDMETHOD.                    &quot;zif_wb_object~to_string</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_INDEX" CPDNAME="ZIF_WB_OBJECT~WRITE">
   <source>METHOD zif_wb_object~write.

  ENDMETHOD.                    &quot;zif_wb_object~write</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_INDEX" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_INDEX" CMPNAME="CONSTRUCTOR" SCONAME="IM_NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJNAME"/>
   <parameter CLSNAME="ZCL_WB_INDEX" CMPNAME="CONSTRUCTOR" SCONAME="IM_ID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJECTID"/>
   <parameter CLSNAME="ZCL_WB_INDEX" CMPNAME="CONSTRUCTOR" SCONAME="IM_STATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJSTATE" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_WB_INDEX" CMPNAME="CONSTRUCTOR" SCONAME="IM_LANGU" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYST-LANGU" PAROPTIONL="X"/>
   <source>METHOD constructor.
    me-&gt;name = im_name.
    me-&gt;id   = im_id.

    me-&gt;state = im_state.
    IF im_state IS NOT SUPPLIED.
      me-&gt;state = &apos;A&apos;.
    ENDIF.

    me-&gt;langu = im_langu.
    IF im_langu IS NOT SUPPLIED.
      me-&gt;langu = space.
    ENDIF.

  ENDMETHOD.                    &quot;constructor</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_DOMAIN" VERSION="1" LANGU="E" DESCRIPT="DDIC Domain" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_WB_DOMAIN" REFCLSNAME="ZIF_WB_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>*&quot;* use this source file for your ABAP unit test classes</localTestClasses>
  <attribute CLSNAME="ZCL_WB_DOMAIN" CMPNAME="DD01V_WA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DD01V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_DOMAIN" CMPNAME="DD07V_TAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZDD07V_TAB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_DOMAIN" CMPNAME="GOTSTATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDGOTSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_DOMAIN" CMPNAME="LANGU" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SY-LANGU" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_DOMAIN" CMPNAME="NAME" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_DOMAIN" CMPNAME="STATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_WB_DOMAIN" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.

    CALL FUNCTION &apos;DDIF_DOMA_GET&apos;
      EXPORTING
        name          = me-&gt;name    &quot; Name of the Domain to be Read
        state         = me-&gt;state    &quot; Read Status of the Domain
        langu         = me-&gt;langu    &quot; Language in which Texts are Read
      IMPORTING
        gotstate      = me-&gt;gotstate    &quot; Status in which Reading took Place
        dd01v_wa      = me-&gt;dd01v_wa    &quot; Header of the Domain
      TABLES
        dd07v_tab     = me-&gt;dd07v_tab    &quot; Fixed Domain Values
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE zcx_wb_object_dont_exist.
    ENDIF.

  ENDMETHOD.                    &quot;zif_wb_object~LOAD</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_DOMAIN" CPDNAME="ZIF_WB_OBJECT~TO_STRING">
   <source>METHOD zif_wb_object~to_string.

  CONCATENATE:
        &apos;Domain:&apos;
        me-&gt;name
        &apos;-&apos;
        me-&gt;dd01v_wa-ddtext
    INTO re_string
    SEPARATED BY &apos; &apos;.

  ENDMETHOD.                    &quot;zif_wb_object~to_string</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_DOMAIN" CPDNAME="ZIF_WB_OBJECT~WRITE">
   <source>METHOD zif_wb_object~write.

  ENDMETHOD.                    &quot;zif_wb_object~write</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_DOMAIN" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_DOMAIN" CMPNAME="CONSTRUCTOR" SCONAME="IM_NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJNAME"/>
   <parameter CLSNAME="ZCL_WB_DOMAIN" CMPNAME="CONSTRUCTOR" SCONAME="IM_STATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJSTATE" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_WB_DOMAIN" CMPNAME="CONSTRUCTOR" SCONAME="IM_LANGU" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYST-LANGU" PAROPTIONL="X"/>
   <source>METHOD constructor.
    me-&gt;name = im_name.

    me-&gt;state = im_state.
    IF im_state IS NOT SUPPLIED.
      me-&gt;state = &apos;A&apos;.
    ENDIF.

    me-&gt;langu = im_langu.
    IF im_langu IS NOT SUPPLIED.
      me-&gt;langu = space.
    ENDIF.

  ENDMETHOD.                    &quot;constructor</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_DATA_ELEMENT" VERSION="1" LANGU="E" DESCRIPT="Data Element" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_WB_DATA_ELEMENT" REFCLSNAME="ZIF_WB_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>*&quot;* use this source file for your ABAP unit test classes</localTestClasses>
  <attribute CLSNAME="ZCL_WB_DATA_ELEMENT" CMPNAME="DD04V_WA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DD04V" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_DATA_ELEMENT" CMPNAME="GOTSTATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDGOTSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_DATA_ELEMENT" CMPNAME="LANGU" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SY-LANGU" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_DATA_ELEMENT" CMPNAME="NAME" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_DATA_ELEMENT" CMPNAME="STATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DDOBJSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_DATA_ELEMENT" CMPNAME="TPARA_WA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TPARA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_WB_DATA_ELEMENT" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.

    CALL FUNCTION &apos;DDIF_DTEL_GET&apos;
      EXPORTING
        name          = me-&gt;name     &quot; Name of the Data Element to be Read
        state         = me-&gt;state    &quot; Read Status of the Data Element
        langu         = me-&gt;langu    &quot; Language in which Texts are Read
      IMPORTING
        gotstate      = me-&gt;gotstate    &quot; Status in which Reading took Place
        dd04v_wa      = me-&gt;dd04v_wa    &quot; Header of the Data Element
        tpara_wa      = me-&gt;tpara_wa    &quot; Technical Settings of the Table
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.

    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE zcx_wb_object_dont_exist.
    ENDIF.

  ENDMETHOD.                    &quot;zif_wb_object~LOAD</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_DATA_ELEMENT" CPDNAME="ZIF_WB_OBJECT~TO_STRING">
   <source>METHOD zif_wb_object~to_string.

    CONCATENATE:
        &apos;Data Element:&apos;
        me-&gt;name
        &apos;-&apos;
        me-&gt;dd04v_wa-ddtext
    INTO re_string
    SEPARATED BY &apos; &apos;.

  ENDMETHOD.                    &quot;zif_wb_object~to_string</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_DATA_ELEMENT" CPDNAME="ZIF_WB_OBJECT~WRITE">
   <source>METHOD zif_wb_object~write.

  ENDMETHOD.                    &quot;zif_wb_object~write</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_DATA_ELEMENT" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_DATA_ELEMENT" CMPNAME="CONSTRUCTOR" SCONAME="IM_NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJNAME"/>
   <parameter CLSNAME="ZCL_WB_DATA_ELEMENT" CMPNAME="CONSTRUCTOR" SCONAME="IM_STATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DDOBJSTATE" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_WB_DATA_ELEMENT" CMPNAME="CONSTRUCTOR" SCONAME="IM_LANGU" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYST-LANGU" PAROPTIONL="X"/>
   <source>METHOD constructor.

    me-&gt;name = im_name.

    me-&gt;state = im_state.
    IF im_state IS NOT SUPPLIED.
      me-&gt;state = &apos;A&apos;.
    ENDIF.

    me-&gt;langu = im_langu.
    IF im_langu IS NOT SUPPLIED.
      me-&gt;langu = space.
    ENDIF.


  ENDMETHOD.                    &quot;constructor</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_CLASS_LOCAL" VERSION="1" LANGU="E" DESCRIPT="Local Class" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZCL_WB_CLASS">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>INCLUDE zi_wb_fake_class_local.
  INCLUDE zi_wb_fake_no_classes.
  INCLUDE zi_zcl_wb_class_local_fakes.

  CLASS lcl_wb_class_local_test DEFINITION DEFERRED.
  CLASS zcl_wb_class_local DEFINITION LOCAL FRIENDS lcl_wb_class_local_test.

*----------------------------------------------------------------------*
*       CLASS lcl_wb_class_local_test DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
  CLASS lcl_wb_class_local_test DEFINITION FOR TESTING
    DURATION SHORT
    RISK LEVEL HARMLESS
  .

    PUBLIC SECTION.

* Load tests
      METHODS load_class_loaded FOR TESTING.
      METHODS load_class_dont_exist FOR TESTING.
      METHODS load_class_is_interface FOR TESTING.

* Load_all_classes tests
      METHODS load_all_classes_success FOR TESTING.
      METHODS load_all_classes_no_report FOR TESTING.
      METHODS load_all_classes_no_classes FOR TESTING.

* Move_vseo_tabs_to_att tests
      METHODS move_vseo_tabs_to_att_class FOR TESTING.
*    METHODS move_vseo_tabs_to_att_inter FOR TESTING.
*    METHODS move_vseo_tabs_to_att_attri FOR TESTING.
*    METHODS move_vseo_tabs_to_att_metho FOR TESTING.
*    METHODS move_vseo_tabs_to_att_mpara FOR TESTING.
*    METHODS move_vseo_tabs_to_att_mexce FOR TESTING.
*    METHODS move_vseo_tabs_to_att_event FOR TESTING.
*    METHODS move_vseo_tabs_to_att_epara FOR TESTING.
*    METHODS move_vseo_tabs_to_att_iimpl FOR TESTING.
*    METHODS move_vseo_tabs_to_att_iincl FOR TESTING.
*    METHODS move_vseo_tabs_to_att_typsr FOR TESTING.
*    METHODS move_vseo_tabs_to_att_types FOR TESTING.
*    METHODS move_vseo_tabs_to_att_alias FOR TESTING.
*    METHODS move_vseo_tabs_to_att_redef FOR TESTING.
*    METHODS move_vseo_tabs_to_att_exted FOR TESTING.
*    METHODS move_vseo_tabs_to_att_cload FOR TESTING.
*    METHODS move_vseo_tabs_to_att_iload FOR TESTING.
*    METHODS move_vseo_tabs_to_att_tpool FOR TESTING.
*    METHODS move_vseo_tabs_to_att_frnds FOR TESTING.


    PROTECTED SECTION.
**********************************************************************
*  GIVEN
**********************************************************************

* Local Class setup
      METHODS given_class_is
        IMPORTING
          !im_report_name TYPE reposrc-progname
          !im_class_name TYPE seoclsname .
      METHODS given_class_exist .
      METHODS given_class_dont_exist .
      METHODS given_class_is_interface .

* Report/include setup
      METHODS given_report_is
           IMPORTING
             !im_report_name TYPE reposrc-progname.
      METHODS given_report_exist.
      METHODS given_report_dont_exist.
      METHODS given_report_without_class.

* vseo tabs setup
      METHODS given_vseo_tabs_class_filled.

**********************************************************************
*  WHEN
**********************************************************************
      METHODS when_load.
      METHODS when_load_all_classes.
      METHODS when_move_vseo_tabs_to_att.

**********************************************************************
*  THEN
**********************************************************************
* Exceptions
      METHODS then_exception_raised
        IMPORTING
          !im_class_name TYPE seoclsname.
      METHODS then_no_exception_raised.

      METHODS then_class_loaded.
      METHODS then_class_not_loaded.

      METHODS then_all_classes_loaded.
      METHODS then_no_classes_loaded.

      METHODS then_att_class_filled.

    PRIVATE SECTION.
      METHODS setup.
      METHODS teardown.

      DATA o_wb_local_class TYPE REF TO zcl_wb_class_local.
      DATA o_wb_exception TYPE REF TO zcx_wb_objects .


*--------------------------------------------------------------------*
* Load_all_classes context
      DATA v_report_name TYPE reposrc-progname.
      DATA t_loaded_classes TYPE ztt_wb_class_local.
*--------------------------------------------------------------------*
  ENDCLASS.       &quot;lcl_wb_class_local_test



*----------------------------------------------------------------------*
*       CLASS lcl_wb_class_local_test IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
  CLASS lcl_wb_class_local_test IMPLEMENTATION.


    METHOD setup.
      CLEAR me-&gt;o_wb_local_class.
      CLEAR me-&gt;o_wb_exception.
    ENDMETHOD.       &quot;setup


    METHOD teardown.

    ENDMETHOD.       &quot;teardown



**********************************************************************
* Methods under test
**********************************************************************
    METHOD load_class_loaded.

      given_class_exist( ).
      when_load( ).
      then_class_loaded( ).
      then_no_exception_raised( ).

    ENDMETHOD.                    &quot;LOAD_CLASS_LOADED


    METHOD load_class_dont_exist.

      given_class_dont_exist( ).
      when_load( ).
      then_class_not_loaded( ).
      then_exception_raised( &apos;ZCX_CLASS_DONT_EXIST&apos; ).

    ENDMETHOD.                    &quot;LOAD_CLASS_DONT_EXIST


    METHOD load_class_is_interface.

      given_class_is_interface( ).
      when_load( ).
      then_class_not_loaded( ).
      then_exception_raised( &apos;ZCX_IS_INTERFACE&apos; ).

    ENDMETHOD.                    &quot;load_class_is_interface


    METHOD load_all_classes_success.

      given_report_exist( ).
      when_load_all_classes( ).
      then_all_classes_loaded( ).
      then_no_exception_raised( ).

    ENDMETHOD.       &quot;load_all_classes_success

    METHOD load_all_classes_no_report.

      given_report_dont_exist( ).
      when_load_all_classes( ).
      then_no_classes_loaded( ).
      then_exception_raised( &apos;ZCX_WB_REPORT_DONT_EXIST&apos; ).

    ENDMETHOD.       &quot;load_all_classes_success


    METHOD load_all_classes_no_classes.

      given_report_without_class( ).
      when_load_all_classes( ).
      then_no_classes_loaded( ).
      then_exception_raised( &apos;ZCX_WB_REPORT_WITHOUT_CLASS&apos; ).

    ENDMETHOD.       &quot;load_all_classes_success




    METHOD move_vseo_tabs_to_att_class.

      given_vseo_tabs_class_filled( ).
      when_move_vseo_tabs_to_att( ).
      then_att_class_filled( ).

    ENDMETHOD.                    &quot;move_vseo_tabs_to_att_class














**********************************************************************
*  GIVEN
**********************************************************************

    METHOD given_class_dont_exist.
      given_class_is( im_report_name = &apos;ZI_WB_FAKE_CLASS_LOCAL&apos; im_class_name = &apos;ZCL_NOT_CREATED_CLASS&apos; ).
    ENDMETHOD.                    &quot;given_class_dont_exist


    METHOD given_class_exist.
      given_class_is( im_report_name = &apos;ZI_WB_FAKE_CLASS_LOCAL&apos; im_class_name = &apos;LCL_A&apos; ).
    ENDMETHOD.                    &quot;given_class_exist

    METHOD given_class_is.

      CREATE OBJECT me-&gt;o_wb_local_class
        EXPORTING
          im_program    = im_report_name
          im_class_name = im_class_name.

    ENDMETHOD.                    &quot;given_class_is

    METHOD given_class_is_interface.
      given_class_is( im_report_name = &apos;ZI_WB_FAKE_CLASS_LOCAL&apos; im_class_name = &apos;ZIF_WB_FAKE_INTERFACE&apos; ).
    ENDMETHOD.                    &quot;given_class_is_interface

    METHOD given_report_is.
      me-&gt;v_report_name = im_report_name.
    ENDMETHOD.                    &quot;given_report_is

    METHOD given_report_exist.
      given_report_is( im_report_name = &apos;ZI_WB_FAKE_CLASS_LOCAL&apos; ).
    ENDMETHOD.                    &quot;given_report_exist

    METHOD given_report_dont_exist.
      given_report_is( im_report_name = &apos;ZI_WB_FAKE_NOT_CREATED&apos; ).
    ENDMETHOD.                    &quot;given_report_dont_exist

    METHOD given_report_without_class.
      given_report_is( im_report_name = &apos;ZI_WB_FAKE_NO_CLASSES&apos; ).
    ENDMETHOD.                    &quot;given_report_without_class



    METHOD given_vseo_tabs_class_filled.

      CREATE OBJECT me-&gt;o_wb_local_class
        EXPORTING
          im_program    = space
          im_class_name = lcl_wb_class_local_stub=&gt;create_class_name( ).

      me-&gt;o_wb_local_class-&gt;t_vseo_tabs-class_tab = lcl_wb_class_local_stub=&gt;create_vseo_tabs_class( ).

    ENDMETHOD.                    &quot;given_vseo_tabs_class_filled


**********************************************************************
*  WHEN
**********************************************************************
    METHOD when_load.

      TRY .
          me-&gt;o_wb_local_class-&gt;zif_wb_object~load( ).
        CATCH zcx_wb_objects INTO me-&gt;o_wb_exception.

      ENDTRY.

    ENDMETHOD.                    &quot;when_load

    METHOD when_load_all_classes.

      TRY .
          me-&gt;t_loaded_classes = zcl_wb_class_local=&gt;load_all_classes( im_program = me-&gt;v_report_name ).
        CATCH zcx_wb_report_dont_exist INTO me-&gt;o_wb_exception.       &quot; Report/Include doesn&apos;t exist
        CATCH zcx_wb_report_without_class INTO me-&gt;o_wb_exception.    &quot; Report/Include without classes
      ENDTRY.

    ENDMETHOD.                    &quot;WHEN_LOAD_ALL_CLASSES


    METHOD when_move_vseo_tabs_to_att.

      me-&gt;o_wb_local_class-&gt;move_vseo_tabs_to_att( im_vseo_tabs = me-&gt;o_wb_local_class-&gt;t_vseo_tabs ).

    ENDMETHOD.                    &quot;when_move_vseo_tabs_to_att

**********************************************************************
*  THEN
**********************************************************************
    METHOD then_class_loaded.

      cl_aunit_assert=&gt;assert_not_initial(
        EXPORTING
          act              = me-&gt;o_wb_local_class-&gt;class-clsname    &quot; Actual Data Object
          msg              = &apos;Class name not loaded&apos;    &quot; Message in Case of Error
      ).

    ENDMETHOD.                    &quot;then_class_loaded

    METHOD then_class_not_loaded.

      cl_aunit_assert=&gt;assert_initial(
        EXPORTING
          act              = me-&gt;o_wb_local_class-&gt;class-clsname    &quot; Actual Data Object
          msg              = &apos;Class name not loaded&apos;    &quot; Message in Case of Error
      ).

    ENDMETHOD.                    &quot;then_class_not_loaded


    METHOD then_exception_raised.

* TODO: how to dynamically assert that a specific exception was thrown?

      cl_aunit_assert=&gt;assert_bound(
        EXPORTING
          act              = me-&gt;o_wb_exception    &quot; Reference Variable to Be Checked
*        msg              =     &quot; Error Message
      ).

    ENDMETHOD.                    &quot;then_exception_raised


    METHOD then_no_exception_raised.

      cl_aunit_assert=&gt;assert_not_bound(
        EXPORTING
          act              = me-&gt;o_wb_exception    &quot; Reference Variable to Be Checked
*        msg              =     &quot; Error Message
      ).
    ENDMETHOD.                    &quot;then_no_exception_raised

    METHOD then_all_classes_loaded.

      cl_aunit_assert=&gt;assert_not_initial(
        EXPORTING
          act              = me-&gt;t_loaded_classes    &quot; Actual Data Object
          msg              = &apos;Loaded classes are empty&apos;    &quot; Message in Case of Error
      ).

      DATA lwa_loaded_class LIKE LINE OF me-&gt;t_loaded_classes.
      LOOP AT me-&gt;t_loaded_classes INTO lwa_loaded_class.

        cl_aunit_assert=&gt;assert_not_initial(
          EXPORTING
            act              = lwa_loaded_class-&gt;class-clsname    &quot; Actual Data Object
            msg              = &apos;Class name not loaded&apos;    &quot; Message in Case of Error
        ).

      ENDLOOP.

    ENDMETHOD.                    &quot;then_all_classes_loaded

    METHOD then_no_classes_loaded.

      cl_aunit_assert=&gt;assert_initial(
        EXPORTING
          act              = me-&gt;t_loaded_classes    &quot; Actual Data Object
          msg              = &apos;Loaded classes are empty&apos;    &quot; Message in Case of Error
      ).

    ENDMETHOD.                    &quot;then_no_classes_loaded

    METHOD then_att_class_filled.

      DATA lwa_vseo_tabs TYPE saboo_vseot.

      DATA lwa_att_class TYPE vseoclass.
      lwa_vseo_tabs-class_tab = lcl_wb_class_local_stub=&gt;create_vseo_tabs_class( ).

      READ TABLE lwa_vseo_tabs-class_tab WITH KEY clsname = me-&gt;o_wb_local_class-&gt;class-clsname INTO lwa_att_class.
      IF sy-subrc IS INITIAL.

        cl_aunit_assert=&gt;assert_equals(
          EXPORTING
            exp                  = lwa_att_class    &quot; Data Object with Expected Type
            act                  = me-&gt;o_wb_local_class-&gt;class    &quot; Data Object with Current Value
*    msg                  =     &quot; Message in Case of Error
*    level                = CRITICAL    &quot; Error Severity
*    tol                  =     &quot; Tolerance Range for Floating Point Numbers
*    quit                 = METHOD    &quot; Flow Control in Case of Error
*    ignore_hash_sequence = ABAP_FALSE    &quot; Ignore change sequence in hash tables
*  RECEIVING
*    assertion_failed     =     &quot; Condition not met
        ).

      ENDIF.

    ENDMETHOD.                    &quot;then_att_class_filled

  ENDCLASS.       &quot;lcl_wb_class_local_test</localTestClasses>
  <typeUsage CLSNAME="ZCL_WB_CLASS_LOCAL" TYPEGROUP="SABOO" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>SABOO</forwardDeclaration>
  <attribute CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="CLASS_NAME" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="VSEOCLASS-CLSNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="PROGRAM" VERSION="1" LANGU="E" DESCRIPT="ABAP Program/Include Name" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="PROGRAMM" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="T_VSEO_TABS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SABOO_VSEOT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCL_WB_CLASS_LOCAL" REFCLSNAME="ZCL_WB_CLASS" VERSION="1" STATE="1">
   <redefinition CLSNAME="ZCL_WB_CLASS_LOCAL" REFCLSNAME="ZCL_WB_CLASS" VERSION="1" MTDNAME="ZIF_WB_OBJECT~LOAD" EXPOSURE="0"/>
   <redefinition CLSNAME="ZCL_WB_CLASS_LOCAL" REFCLSNAME="ZCL_WB_CLASS" VERSION="1" MTDNAME="ZIF_WB_OBJECT~TO_STRING" EXPOSURE="0"/>
  </inheritance>
  <interfaceMethod CLSNAME="ZCL_WB_CLASS_LOCAL" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.

  DATA lt_source_code TYPE saboo_sourt.
  DATA r_wb_scanner TYPE REF TO zcl_wb_scanner_objects.
  DATA lwa_class LIKE LINE OF me-&gt;t_vseo_tabs-class_tab.

  READ REPORT me-&gt;program INTO lt_source_code.
  zcl_wb_scanner_objects=&gt;create(
    IMPORTING
      scanner = r_wb_scanner
    CHANGING
      sourc_tab = lt_source_code  ).

  me-&gt;t_vseo_tabs = r_wb_scanner-&gt;scan_source( ).

  READ TABLE  me-&gt;t_vseo_tabs-class_tab INTO lwa_class WITH KEY clsname = me-&gt;class_name.
  IF sy-subrc IS INITIAL.
    me-&gt;move_vseo_tabs_to_att(
    EXPORTING
      im_vseo_tabs = me-&gt;t_vseo_tabs
    ).
  ELSE.
    RAISE EXCEPTION TYPE zcx_wb_class_dont_exist.
  ENDIF.

ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_CLASS_LOCAL" CPDNAME="ZIF_WB_OBJECT~TO_STRING">
   <source>method zif_wb_object~to_string.

    CONCATENATE:
        &apos;Program:&apos;
        me-&gt;program
        &apos; - Local Class:&apos;
        me-&gt;class-clsname
        &apos;-&apos;
        me-&gt;class-descript
    INTO re_string
    SEPARATED BY &apos; &apos;.

endmethod.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_PROGRAM" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="PROGRAMM"/>
   <parameter CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_CLASS_NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="VSEOCLASS-CLSNAME"/>
   <source>method CONSTRUCTOR.
    super-&gt;constructor( ).

    me-&gt;program     = im_program.
    me-&gt;class_name  = im_class_name.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="LOAD_ALL_CLASSES" VERSION="1" LANGU="E" DESCRIPT="Load all local classes inside a program/include" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="LOAD_ALL_CLASSES" SCONAME="IM_PROGRAM" VERSION="1" LANGU="E" DESCRIPT="ABAP Program Name" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="PROGRAMM"/>
   <parameter CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="LOAD_ALL_CLASSES" SCONAME="RE_T_R_CLASSES" VERSION="1" LANGU="E" DESCRIPT="Table of WB local classes" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTT_WB_CLASS_LOCAL"/>
   <exception CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="LOAD_ALL_CLASSES" SCONAME="ZCX_WB_REPORT_DONT_EXIST" VERSION="1" LANGU="E" DESCRIPT="Report/Include doesn&apos;t exist" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="LOAD_ALL_CLASSES" SCONAME="ZCX_WB_REPORT_WITHOUT_CLASS" VERSION="1" LANGU="E" DESCRIPT="Report/Include without classes" MTDTYPE="0" EDITORDER="2 "/>
   <source>METHOD load_all_classes.

  DATA r_wb_scanner TYPE REF TO zcl_wb_scanner_objects.
  DATA t_source_code TYPE saboo_sourt.
  DATA lwa_vseo_tabs TYPE saboo_vseot .
  DATA lwa_class LIKE LINE OF lwa_vseo_tabs-class_tab.

  READ REPORT im_program INTO t_source_code.
  IF sy-subrc IS NOT INITIAL.
    &quot; If the report doesn&apos;t exist or cannot be read, the same exception is thrown
    RAISE EXCEPTION TYPE zcx_wb_report_dont_exist.
  ENDIF.

  zcl_wb_scanner_objects=&gt;create(
    IMPORTING
      scanner = r_wb_scanner
    CHANGING
      sourc_tab = t_source_code  ).

  lwa_vseo_tabs = r_wb_scanner-&gt;scan_source( ).

  DATA lr_local_class TYPE REF TO zcl_wb_class_local.

  IF lwa_vseo_tabs-class_tab IS INITIAL.
    RAISE EXCEPTION TYPE zcx_wb_report_without_class.
  ENDIF.

  LOOP AT lwa_vseo_tabs-class_tab INTO lwa_class.

    CREATE OBJECT lr_local_class
      EXPORTING
        im_program    = im_program
        im_class_name = lwa_class-clsname.

    lr_local_class-&gt;move_vseo_tabs_to_att( im_vseo_tabs = lwa_vseo_tabs ).

    APPEND lr_local_class TO re_t_r_classes.

  ENDLOOP.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="MOVE_VSEO_TABS_TO_ATT" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="MOVE_VSEO_TABS_TO_ATT" SCONAME="IM_VSEO_TABS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_VSEOT"/>
   <source>method MOVE_VSEO_TABS_TO_ATT.

* Class
    DATA lwa_vseoclass TYPE vseoclass.
    LOOP AT im_vseo_tabs-class_tab INTO lwa_vseoclass
        WHERE clsname = me-&gt;class_name.
      me-&gt;class = lwa_vseoclass.
    ENDLOOP.

* Attributes
    DATA lwa_vseoattrib TYPE vseoattrib.
    LOOP AT im_vseo_tabs-attri_tab INTO lwa_vseoattrib
      WHERE clsname = me-&gt;class_name.
      APPEND lwa_vseoattrib TO me-&gt;attributes.
    ENDLOOP.

* Methods
    DATA lwa_vseomethod TYPE vseomethod.
    LOOP AT im_vseo_tabs-metho_tab INTO lwa_vseomethod
      WHERE clsname = me-&gt;class_name.
      APPEND lwa_vseomethod TO me-&gt;methods.
    ENDLOOP.

* Method parameters
*    DATA lwa_mpara_tab TYPE vseomepara.
*    LOOP AT im_vseo_tabs-mpara_tab INTO lwa_mpara_tab
*      WHERE clsname = me-&gt;class_name.
*      APPEND lwa_mpara_tab TO me-&gt;parameters.
*    ENDLOOP.

* Exceptions
    DATA lwa_mexce_tab TYPE vseoexcep.
    LOOP AT im_vseo_tabs-mexce_tab INTO lwa_mexce_tab
      WHERE clsname = me-&gt;class_name.
      APPEND lwa_mexce_tab TO me-&gt;exceps.
    ENDLOOP.

* Interfaces
    DATA lwa_VSEOIMPLEM TYPE VSEOIMPLEM.
    LOOP AT im_vseo_tabs-iimpl_tab INTO lwa_VSEOIMPLEM
      WHERE clsname = me-&gt;class_name.
      APPEND lwa_VSEOIMPLEM TO me-&gt;implementings.
    ENDLOOP.

* Types
    DATA lwa_VSEOTYPE TYPE VSEOTYPE.
    LOOP AT im_vseo_tabs-types_tab INTO lwa_VSEOTYPE
      WHERE clsname = me-&gt;class_name.
      APPEND lwa_VSEOTYPE TO me-&gt;types.
    ENDLOOP.


endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_CLASS_GLOBAL" VERSION="1" LANGU="E" DESCRIPT="ABAP global class" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZCL_WB_CLASS">
  <friends CLSNAME="ZCL_WB_CLASS_GLOBAL" REFCLSNAME="ZCL_WB_CLASS_GLOBAL_STUB" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>CLASS zcl_wb_class_global_test DEFINITION DEFERRED.
CLASS zcl_wb_class_global DEFINITION LOCAL FRIENDS zcl_wb_class_global_test.

*----------------------------------------------------------------------*
*       CLASS zcl_Wb_Class_Global_Test DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS zcl_wb_class_global_test DEFINITION FOR TESTING
  FINAL
  CREATE PUBLIC
  DURATION SHORT
  RISK LEVEL HARMLESS
.

  PUBLIC SECTION.

    METHODS load_class_loaded FOR TESTING.
    METHODS load_class_dont_exist FOR TESTING.
    METHODS load_class_is_interface FOR TESTING.
    METHODS load_class_is_model_only FOR TESTING.

    METHODS load_subclasses_0_sub FOR TESTING.
    METHODS load_subclasses_1_sub FOR TESTING.
    METHODS load_subclasses_1_grandma FOR TESTING.

  PROTECTED SECTION.

*  GIVEN
    METHODS given_class_is
      IMPORTING
        !im_class_name TYPE seoclsname .
    METHODS given_class_exist .
    METHODS given_class_dont_exist .
    METHODS given_class_is_interface .
    METHODS given_class_model_only .

    METHODS given_no_subclasses.
    METHODS given_1_subclass.
    METHODS given_1_grandma_class.

*  WHEN
    METHODS when_load .
    METHODS when_load_subclasses.

*  THEN
    METHODS then_class_loaded .
    METHODS then_class_not_loaded .
    METHODS then_exception_raised
      IMPORTING
        !im_class_name TYPE seoclsname .
    METHODS then_no_exception_raised .
    METHODS then_no_subclasses_loaded.
    METHODS then_1_subclass_loaded.
    METHODS then_all_child_classes_loaded.

  PRIVATE SECTION.
    METHODS setup.
    METHODS teardown.
    DATA o_wb_global_class TYPE REF TO zcl_wb_class_global .
    DATA o_wb_exception TYPE REF TO zcx_wb_objects .



* load_subclasses context
    DATA v_superclass TYPE seoclsname.

ENDCLASS.       &quot;zcl_Wb_Class_Global_Test


*----------------------------------------------------------------------*
*       CLASS zcl_Wb_Class_Global_Test IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS zcl_wb_class_global_test IMPLEMENTATION.

  METHOD setup.
    CLEAR me-&gt;o_wb_global_class.
    CLEAR me-&gt;o_wb_exception.

  ENDMETHOD.       &quot;setup


  METHOD teardown.

  ENDMETHOD.       &quot;teardown


************************************************
* Methods Under Test
************************************************
  METHOD load_class_dont_exist.

    given_class_dont_exist( ).
    when_load( ).
    then_class_not_loaded( ).
    then_exception_raised( &apos;ZCX_CLASS_DONT_EXIST&apos; ).
  ENDMETHOD.                    &quot;LOAD_CLASS_DONT_EXIST

  METHOD load_class_is_interface.
    given_class_is_interface( ).
    when_load( ).
    then_class_not_loaded( ).
    then_exception_raised( &apos;ZCX_IS_INTERFACE&apos; ).
  ENDMETHOD.                    &quot;load_class_is_interface


  METHOD load_class_is_model_only.
    given_class_model_only( ).
    when_load( ).
    then_class_not_loaded( ).
    then_exception_raised( &apos;ZCX_CLASS_IS_MODEL_ONLY&apos; ).
  ENDMETHOD.                    &quot;load_class_is_model_only

  METHOD load_class_loaded.
    given_class_exist( ).
    when_load( ).
    then_class_loaded( ).
    then_no_exception_raised( ).
  ENDMETHOD.                    &quot;LOAD_CLASS_LOADED

  METHOD load_subclasses_0_sub.
    given_no_subclasses( ).
    when_load_subclasses( ).
    then_no_subclasses_loaded( ).
  ENDMETHOD.                    &quot;load_subclasses_0_sub

  METHOD load_subclasses_1_sub.
    given_1_subclass( ).
    when_load_subclasses( ).
    then_1_subclass_loaded( ).
  ENDMETHOD.                    &quot;load_subclasses_1_sub

  METHOD load_subclasses_1_grandma.
    given_1_grandma_class( ).
    when_load_subclasses( ).
    then_all_child_classes_loaded( ).
  ENDMETHOD.                    &quot;LOAD_SUBCLASSES_1_GRANDMA

************************************************
* GIVEN
************************************************
  METHOD given_class_dont_exist.
    given_class_is( &apos;ZCL_NOT_CREATED_CLASS&apos; ).
  ENDMETHOD.                    &quot;given_class_dont_exist

  METHOD given_class_exist.
    given_class_is( &apos;ZCL_WB_CLASS_GLOBAL&apos; ).
  ENDMETHOD.                    &quot;given_class_exist

  METHOD given_class_is.

    DATA lwa_seoclskey TYPE seoclskey.
    lwa_seoclskey-clsname = im_class_name.

    CREATE OBJECT me-&gt;o_wb_global_class
      EXPORTING
        im_clskey                    = lwa_seoclskey
*       im_version                   = SEOC_VERSION_INACTIVE
*       im_state                     = &apos;1&apos;
*       im_with_descriptions         = SEOX_TRUE
*       im_resolve_eventhandler_info = SEOX_FALSE
*       im_with_master_language      = SEOX_FALSE
*       im_with_enhancements         = SEOX_FALSE
*       im_read_active_enha          = SEOX_FALSE
*       im_enha_action               = SEOX_FALSE
*       im_ignore_switches           = &apos;X&apos;
      .

  ENDMETHOD.                    &quot;given_class_is

  METHOD given_class_is_interface.
    given_class_is( &apos;ZIF_WB_FAKE_INTERFACE&apos; ).
  ENDMETHOD.                    &quot;given_class_is_interface

  METHOD given_class_model_only.
* MODEL ONLY seems not exist on NetWeaver 7.31 - Is that right?
    given_class_is( &apos;ZCL_WB_FAKE_MODEL_ONLY&apos; ).
  ENDMETHOD.                    &quot;given_class_model_only

  METHOD given_no_subclasses.
    me-&gt;v_superclass = &apos;ZCL_WB_FAKE_SUBCLASS1_A&apos;.
  ENDMETHOD.                    &quot;given_no_subclasses

  METHOD given_1_subclass.
    me-&gt;v_superclass = &apos;ZCL_WB_FAKE_SUBCLASS1&apos;.
  ENDMETHOD.                    &quot;given_1_subclass

  METHOD given_1_grandma_class.
    me-&gt;v_superclass = &apos;ZCL_WB_FAKE_SUPERCLASS&apos;.
  ENDMETHOD.                    &quot;given_1_grandma_class


************************************************
* WHEN
************************************************
  METHOD when_load.

    TRY .
        me-&gt;o_wb_global_class-&gt;zif_wb_object~load( ).
      CATCH zcx_wb_objects INTO me-&gt;o_wb_exception.
    ENDTRY.

  ENDMETHOD.                    &quot;when_load

  METHOD when_load_subclasses.

    DATA lwa_clskey TYPE seoclskey.
    lwa_clskey-clsname = me-&gt;v_superclass.

    CREATE OBJECT me-&gt;o_wb_global_class
      EXPORTING
        im_clskey                    = lwa_clskey
*       im_version                   = SEOC_VERSION_INACTIVE
*       im_state                     = &apos;1&apos;
*       im_with_descriptions         = SEOX_TRUE
*       im_resolve_eventhandler_info = SEOX_FALSE
*       im_with_master_language      = SEOX_FALSE
*       im_with_enhancements         = SEOX_FALSE
*       im_read_active_enha          = SEOX_FALSE
*       im_enha_action               = SEOX_FALSE
*       im_ignore_switches           = &apos;X&apos;
      .

    me-&gt;o_wb_global_class-&gt;load_subclasses( ).

*    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
*    DATA lwa_class_mocked TYPE vseoclass.
*    lwa_class_mocked-clsname = me-&gt;v_superclass.
*
*    lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZCL_WB_CLASS_GLOBAL&apos; ).
*    lo_mocker-&gt;attribute( iv_attribute = &apos;CLASS&apos; )-&gt;returns( i_return = lwa_class_mocked  ).
*
*    me-&gt;o_wb_global_class ?= lo_mocker-&gt;generate_mockup( ).
    me-&gt;o_wb_global_class-&gt;load_subclasses( ).

  ENDMETHOD.                    &quot;when_load_subclasses


************************************************
* THEN
************************************************

  METHOD then_class_loaded.

    cl_aunit_assert=&gt;assert_not_initial(
      EXPORTING
        act              = me-&gt;o_wb_global_class-&gt;class-clsname    &quot; Actual Data Object
        msg              = &apos;Class name not loaded&apos;    &quot; Message in Case of Error
    ).

  ENDMETHOD.                    &quot;then_class_loaded

  METHOD then_class_not_loaded.

    cl_aunit_assert=&gt;assert_initial(
      EXPORTING
        act              = me-&gt;o_wb_global_class-&gt;class-clsname    &quot; Actual Data Object
        msg              = &apos;Class name not loaded&apos;    &quot; Message in Case of Error
    ).

  ENDMETHOD.                    &quot;then_class_not_loaded


  METHOD then_exception_raised.

* TODO: how to dynamically assert that a specific exception was thrown?
* answer: via RTTS and an empty reference
    cl_aunit_assert=&gt;assert_bound(
      EXPORTING
        act              = me-&gt;o_wb_exception    &quot; Reference Variable to Be Checked
*        msg              =     &quot; Error Message
    ).

  ENDMETHOD.                    &quot;then_exception_raised


  METHOD then_no_exception_raised.

    cl_aunit_assert=&gt;assert_not_bound(
      EXPORTING
        act              = me-&gt;o_wb_exception    &quot; Reference Variable to Be Checked
*        msg              =     &quot; Error Message
    ).
  ENDMETHOD.                    &quot;then_no_exception_raised


  METHOD then_no_subclasses_loaded.
    cl_aunit_assert=&gt;assert_initial(
      EXPORTING
        act              = me-&gt;o_wb_global_class-&gt;subclasses    &quot; Actual Data Object
*    msg              =     &quot; Message in Case of Error
*    level            = CRITICAL    &quot; Error Severity
*    quit             = METHOD    &quot; Flow Control in Case of Error
*  RECEIVING
*    assertion_failed =     &quot; Condition not met
    ).

  ENDMETHOD.                    &quot;then_no_subclasses_loaded

  METHOD then_1_subclass_loaded.

    DATA lt_exp TYPE  seo_relkeys.
    DATA lwa_exp TYPE  seorelkey.

    lwa_exp-clsname = &apos;ZCL_WB_FAKE_SUBCLASS1_A&apos;.
    lwa_exp-refclsname = &apos;ZCL_WB_FAKE_SUBCLASS1&apos;.
    APPEND lwa_exp TO lt_exp.

    cl_aunit_assert=&gt;assert_equals(
      EXPORTING
        exp                  = lt_exp    &quot; Data Object with Expected Type
        act                  = me-&gt;o_wb_global_class-&gt;subclasses    &quot; Data Object with Current Value
*    msg                  =     &quot; Message in Case of Error
*    level                = CRITICAL    &quot; Error Severity
*    tol                  =     &quot; Tolerance Range for Floating Point Numbers
*    quit                 = METHOD    &quot; Flow Control in Case of Error
*    ignore_hash_sequence = ABAP_FALSE    &quot; Ignore change sequence in hash tables
*  RECEIVING
*    assertion_failed     =     &quot; Condition not met
    ).

  ENDMETHOD.                    &quot;then_1_subclass_loaded

  METHOD then_all_child_classes_loaded.

    DATA lt_exp TYPE  seo_relkeys.
    DATA lwa_exp TYPE  seorelkey.

    lwa_exp-clsname = &apos;ZCL_WB_FAKE_SUBCLASS1&apos;.
    lwa_exp-refclsname = &apos;ZCL_WB_FAKE_SUPERCLASS&apos;.
    APPEND lwa_exp TO lt_exp.

    lwa_exp-clsname = &apos;ZCL_WB_FAKE_SUBCLASS2&apos;.
    lwa_exp-refclsname = &apos;ZCL_WB_FAKE_SUPERCLASS&apos;.
    APPEND lwa_exp TO lt_exp.

    lwa_exp-clsname = &apos;ZCL_WB_FAKE_SUBCLASS1_A&apos;.
    lwa_exp-refclsname = &apos;ZCL_WB_FAKE_SUBCLASS1&apos;.
    APPEND lwa_exp TO lt_exp.

    cl_aunit_assert=&gt;assert_equals(
      EXPORTING
        exp                  = lt_exp    &quot; Data Object with Expected Type
        act                  = me-&gt;o_wb_global_class-&gt;subclasses    &quot; Data Object with Current Value
*    msg                  =     &quot; Message in Case of Error
*    level                = CRITICAL    &quot; Error Severity
*    tol                  =     &quot; Tolerance Range for Floating Point Numbers
*    quit                 = METHOD    &quot; Flow Control in Case of Error
*    ignore_hash_sequence = ABAP_FALSE    &quot; Ignore change sequence in hash tables
*  RECEIVING
*    assertion_failed     =     &quot; Condition not met
    ).



  ENDMETHOD.                    &quot;then_all_child_classes_loaded



ENDCLASS.       &quot;zcl_Wb_Class_Global_Test</localTestClasses>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CLSKEY" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOCLSKEY" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="ENHANCEMENT_ATTRIBUTES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHCLASSTABATTRIB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="ENHANCEMENT_EVENTS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHCLASSTABEVENT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="ENHANCEMENT_IMPLEMENTINGS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHCLASSTABIMPLEMENTING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="ENHANCEMENT_METHODS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHMETH_TABHEADER" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="ENHANCEMENT_TYPES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHTYPE_TAB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="ENHA_ACTION" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="9 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="EXPLORE_IMPLEMENTINGS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOK_INT_TYPEINFOS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="EXPLORE_INHERITANCE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOK_CLS_TYPEINFOS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="IGNORE_SWITCHES" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="10 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="CHAR1" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="READ_ACTIVE_ENHA" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="RESOLVE_EVENTHANDLER_INFO" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="STATE" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="VERSION" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOVERSION" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="WITH_DESCRIPTIONS" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="WITH_ENHANCEMENTS" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="WITH_MASTER_LANGUAGE" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCL_WB_CLASS_GLOBAL" REFCLSNAME="ZCL_WB_CLASS" VERSION="1" STATE="1">
   <redefinition CLSNAME="ZCL_WB_CLASS_GLOBAL" REFCLSNAME="ZCL_WB_CLASS" VERSION="1" MTDNAME="GET_DIRECT_IMPLEMENTATIONS" EXPOSURE="2"/>
   <redefinition CLSNAME="ZCL_WB_CLASS_GLOBAL" REFCLSNAME="ZCL_WB_CLASS" VERSION="1" MTDNAME="LOAD_SUBCLASSES" EXPOSURE="1"/>
   <redefinition CLSNAME="ZCL_WB_CLASS_GLOBAL" REFCLSNAME="ZCL_WB_CLASS" VERSION="1" MTDNAME="ZIF_WB_OBJECT~LOAD" EXPOSURE="0"/>
  </inheritance>
  <interfaceMethod CLSNAME="ZCL_WB_CLASS_GLOBAL" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.

    CALL FUNCTION &apos;SEO_CLASS_TYPEINFO_GET&apos;
      EXPORTING
        clskey                        = me-&gt;clskey
        version                       = me-&gt;version
        state                         = me-&gt;state
        with_descriptions             = me-&gt;with_descriptions
        resolve_eventhandler_typeinfo = me-&gt;resolve_eventhandler_info
        with_master_language          = me-&gt;with_master_language
        with_enhancements             = me-&gt;with_enhancements
        read_active_enha              = me-&gt;read_active_enha
        enha_action                   = me-&gt;enha_action
        ignore_switches               = me-&gt;ignore_switches
      IMPORTING
        class                         = me-&gt;class
        attributes                    = me-&gt;attributes
        methods                       = me-&gt;methods
        events                        = me-&gt;events
        types                         = me-&gt;types
        parameters                    = me-&gt;parameters
        exceps                        = me-&gt;exceps
        implementings                 = me-&gt;implementings
        inheritance                   = me-&gt;inheritance
        redefinitions                 = me-&gt;redefinitions
        impl_details                  = me-&gt;impl_details
        friendships                   = me-&gt;friendships
        typepusages                   = me-&gt;typepusages
        clsdeferrds                   = me-&gt;clsdeferrds
        intdeferrds                   = me-&gt;intdeferrds
        explore_inheritance           = me-&gt;explore_inheritance
        explore_implementings         = me-&gt;explore_implementings
        aliases                       = me-&gt;aliases
        enhancement_methods           = me-&gt;enhancement_methods
        enhancement_attributes        = me-&gt;enhancement_attributes
        enhancement_events            = me-&gt;enhancement_events
        enhancement_implementings     = me-&gt;enhancement_implementings
        enhancement_types             = me-&gt;enhancement_types
      EXCEPTIONS
        not_existing                  = 1
        is_interface                  = 2
        model_only                    = 3
        OTHERS                        = 4.

    CASE sy-subrc.
      WHEN 1.
        RAISE EXCEPTION TYPE zcx_wb_class_dont_exist.
      WHEN 2.
        RAISE EXCEPTION TYPE zcx_wb_is_interface.
      WHEN 3.
        RAISE EXCEPTION TYPE zcx_wb_class_is_model_only.
    ENDCASE.

    me-&gt;load_subclasses( ).

  ENDMETHOD.                    &quot;zif_wb_object~load</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_CLSKEY" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCLSKEY"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_VERSION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOVERSION" PARVALUE="SEOC_VERSION_INACTIVE"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_STATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOSTATE" PARVALUE="&apos;1&apos;"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_WITH_DESCRIPTIONS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_TRUE"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_RESOLVE_EVENTHANDLER_INFO" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_WITH_MASTER_LANGUAGE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_WITH_ENHANCEMENTS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_READ_ACTIVE_ENHA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_ENHA_ACTION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="9 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_IGNORE_SWITCHES" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="10 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR1" PARVALUE="&apos;X&apos;"/>
   <source>METHOD constructor.
    super-&gt;constructor( ).
    me-&gt;clskey                    = im_clskey.
    me-&gt;version                   = im_version.
    me-&gt;state                     = im_state.
    me-&gt;with_descriptions         = im_with_descriptions.
    me-&gt;resolve_eventhandler_info = im_resolve_eventhandler_info.
    me-&gt;with_master_language      = im_with_master_language.
    me-&gt;with_enhancements         = im_with_enhancements.
    me-&gt;read_active_enha          = im_read_active_enha.
    me-&gt;enha_action               = im_enha_action.
    me-&gt;ignore_switches           = im_ignore_switches.
  ENDMETHOD.                    &quot;CONSTRUCTOR</source>
  </method>
  <method CLSNAME="ZCL_WB_CLASS" CMPNAME="GET_DIRECT_IMPLEMENTATIONS" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_direct_implementations.

    data lt_partial_result type zseo_class_names.

    FIELD-SYMBOLS &lt;implemented_interface&gt; TYPE seor_implementing_r.
    DATA lwa_direct_implementation TYPE seoclass.
    DATA lo_interface TYPE REF TO cl_oo_interface.
    DATA lt_comprised_interfaces TYPE seo_relkeys. &quot; interfaces that an interface implements
    FIELD-SYMBOLS &lt;wa_comprised_interface&gt; TYPE seorelkey.


* implementings has all interfaces that are implemented by the class no matter if directly or not
    LOOP AT me-&gt;implementings ASSIGNING &lt;implemented_interface&gt;.

      TRY.
&quot; Get all interfaces that each interface implements (as known as &apos;Comprised Interfaces&apos;)
          lo_interface ?= cl_oo_interface=&gt;get_instance( clsname = &lt;implemented_interface&gt;-refclsname  ).
          lt_comprised_interfaces = lo_interface-&gt;get_comprised_interfaces( ).
          CATCH cx_class_not_existent.  &quot; Class Does Not Exist
            CONTINUE.
        ENDTRY.


&quot; Check if a comprised interface implements one of the know interfaces (which the class implements)
          LOOP AT lt_comprised_interfaces ASSIGNING &lt;wa_comprised_interface&gt;.

*            READ TABLE me-&gt;implementings WITH KEY clsname = me-&gt;refclsname refclsname = &lt;wa_comprised_interface&gt;-refclsname.


          endloop.








        lwa_direct_implementation = &lt;implemented_interface&gt;-refclsname.
        APPEND lwa_direct_implementation TO re_t_direct_implementations.

        CLEAR lo_interface.
      ENDLOOP.

    ENDMETHOD.                    &quot;GET_DIRECT_IMPLEMENTATIONS</source>
  </method>
  <method CLSNAME="ZCL_WB_CLASS" CMPNAME="LOAD_SUBCLASSES" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD load_subclasses.
    DATA lo_oo_class TYPE REF TO cl_oo_class.

    TRY.
        lo_oo_class ?= cl_oo_class=&gt;get_instance( clsname = me-&gt;clskey-clsname ).
        me-&gt;subclasses = lo_oo_class-&gt;get_subclasses( ).
      CATCH cx_class_not_existent.    &quot; Class Does Not Exist
    ENDTRY.

  ENDMETHOD.                    &quot;load_subclasses</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_CLASS" VERSION="1" LANGU="E" DESCRIPT="Generic class" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_WB_CLASS" REFCLSNAME="ZIF_WB_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_WB_CLASS" TYPEGROUP="SEOO" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>SEOO</forwardDeclaration>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="ALIASES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="16 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_ALIASES_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="ATTRIBUTES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_ATTRIBUTES_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="CLASS" VERSION="1" LANGU="E" DESCRIPT="Generierte Tabelle zu einem View" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="VSEOCLASS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="CLSDEFERRDS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="14 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOT_CLSDEFERRDS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="EVENTS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_EVENTS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="EXCEPS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOS_EXCEPTIONS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="FRIENDSHIPS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="12 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOF_FRIENDSHIPS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="IMPLEMENTINGS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOR_IMPLEMENTINGS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="IMPL_DETAILS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="11 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOR_REDEFINITIONS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="INHERITANCE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="9 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="VSEOEXTEND" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="INTDEFERRDS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="15 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOT_INTDEFERRDS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="METHODS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_METHODS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="PARAMETERS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOS_PARAMETERS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="REDEFINITIONS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="10 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOR_REDEFINITIONS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="SUBCLASSES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="17 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEO_RELKEYS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="TYPEPUSAGES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="13 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOT_TYPEPUSAGES_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="TYPES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_TYPES_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_WB_CLASS" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.

  ENDMETHOD.                    &quot;ZIF_WB_OBJECT~LOAD</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_CLASS" CPDNAME="ZIF_WB_OBJECT~TO_STRING">
   <source>METHOD zif_wb_object~to_string.

    CONCATENATE:
        &apos;Class:&apos;
        me-&gt;class-clsname
        &apos;-&apos;
        me-&gt;class-descript
    INTO re_string
    SEPARATED BY &apos; &apos;.

  ENDMETHOD.                    &quot;zif_wb_object~to_string</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_CLASS" CPDNAME="ZIF_WB_OBJECT~WRITE">
   <source>METHOD zif_wb_object~write.
* This method is currently for demonstration purposes of the framework
* sooner or later it will be removed from here.
* DO NOT USE!

    WRITE:
      &apos;Class:&apos;,
      me-&gt;class-clsname,
      &apos; - &apos;,
      me-&gt;class-descript.
    NEW-LINE.

*    WRITE me-&gt;class-version           .  NEW-LINE.
*    WRITE me-&gt;class-langu             .  NEW-LINE.
*    WRITE me-&gt;class-descript          .  NEW-LINE.
*    WRITE me-&gt;class-uuid              .  NEW-LINE.
*    WRITE me-&gt;class-category          .  NEW-LINE.
*    WRITE me-&gt;class-exposure          .  NEW-LINE.
*    WRITE me-&gt;class-state             .  NEW-LINE.
*    WRITE me-&gt;class-release           .  NEW-LINE.
*    WRITE me-&gt;class-author            .  NEW-LINE.
*    WRITE me-&gt;class-createdon         .  NEW-LINE.
*    WRITE me-&gt;class-changedby         .  NEW-LINE.
*    WRITE me-&gt;class-changedon         .  NEW-LINE.
*    WRITE me-&gt;class-chgdanyby         .  NEW-LINE.
*    WRITE me-&gt;class-chgdanyon         .  NEW-LINE.
*    WRITE me-&gt;class-clsembed          .  NEW-LINE.
*    WRITE me-&gt;class-clsabstrct        .  NEW-LINE.
*    WRITE me-&gt;class-clsfinal          .  NEW-LINE.
*    WRITE me-&gt;class-clsccincl         .  NEW-LINE.
*    WRITE me-&gt;class-remote            .  NEW-LINE.
*    WRITE me-&gt;class-fixpt             .  NEW-LINE.
*    WRITE me-&gt;class-varcl             .  NEW-LINE.
*    WRITE me-&gt;class-unicode           .  NEW-LINE.
*    WRITE me-&gt;class-rstat             .  NEW-LINE.
*    WRITE me-&gt;class-clsdefatt         .  NEW-LINE.
*    WRITE me-&gt;class-clsdefmtd         .  NEW-LINE.
*    WRITE me-&gt;class-clsdefint         .  NEW-LINE.
*    WRITE me-&gt;class-clsbcimpl         .  NEW-LINE.
*    WRITE me-&gt;class-r3release         .  NEW-LINE.
*    WRITE me-&gt;class-clsbctrans        .  NEW-LINE.
*    WRITE me-&gt;class-clsbccat          .  NEW-LINE.
*    WRITE me-&gt;class-clsaddon          .  NEW-LINE.
*    WRITE me-&gt;class-msg_id            .  NEW-LINE.
*    WRITE me-&gt;class-clsbcnodel        .  NEW-LINE.
*    WRITE me-&gt;class-clsproxy          .  NEW-LINE.
*    WRITE me-&gt;class-clssharedmemory   .  NEW-LINE.
*    WRITE me-&gt;class-with_unit_tests   .  NEW-LINE.
*    WRITE me-&gt;class-duration_type     .  NEW-LINE.
*    WRITE me-&gt;class-risk_level        .  NEW-LINE.
*    WRITE me-&gt;class-within_package    .  NEW-LINE.

* attributes
    DATA lwa_attributes TYPE vseoattrib.
    WRITE: &apos;Attributes&apos; COLOR 3. NEW-LINE.

    LOOP AT me-&gt;attributes INTO lwa_attributes.
*      WRITE lwa_attributes-clsname        . NEW-LINE.
      WRITE lwa_attributes-cmpname        . NEW-LINE.
*      WRITE lwa_attributes-version        . NEW-LINE.
*      WRITE lwa_attributes-langu          . NEW-LINE.
*      WRITE lwa_attributes-descript       . NEW-LINE.
*      WRITE lwa_attributes-alias          . NEW-LINE.
*      WRITE lwa_attributes-exposure       . NEW-LINE.
*      WRITE lwa_attributes-state          . NEW-LINE.
*      WRITE lwa_attributes-editorder      . NEW-LINE.
*      WRITE lwa_attributes-author         . NEW-LINE.
*      WRITE lwa_attributes-createdon      . NEW-LINE.
*      WRITE lwa_attributes-changedby      . NEW-LINE.
*      WRITE lwa_attributes-changedon      . NEW-LINE.
*      WRITE lwa_attributes-attdecltyp     . NEW-LINE.
*      WRITE lwa_attributes-attdynamic     . NEW-LINE.
*      WRITE lwa_attributes-attgetmtd      . NEW-LINE.
*      WRITE lwa_attributes-attsetmtd      . NEW-LINE.
*      WRITE lwa_attributes-attrdonly      . NEW-LINE.
*      WRITE lwa_attributes-attvalue       . NEW-LINE.
*      WRITE lwa_attributes-attpersist     . NEW-LINE.
*      WRITE lwa_attributes-attexpvirt     . NEW-LINE.
*      WRITE lwa_attributes-typtype        . NEW-LINE.
*      WRITE lwa_attributes-type           . NEW-LINE.
*      WRITE lwa_attributes-tableof        . NEW-LINE.
*      WRITE lwa_attributes-srcrow1        . NEW-LINE.
*      WRITE lwa_attributes-srccolumn1     . NEW-LINE.
*      WRITE lwa_attributes-srcrow2        . NEW-LINE.
*      WRITE lwa_attributes-srccolumn2     . NEW-LINE.
*      WRITE lwa_attributes-refclsname     . NEW-LINE.
*      WRITE lwa_attributes-refcmpname     . NEW-LINE.
*      WRITE lwa_attributes-locked         . NEW-LINE.
*      WRITE lwa_attributes-attkeyfld      . NEW-LINE.
*      WRITE lwa_attributes-attbusobj      . NEW-LINE.
*      WRITE lwa_attributes-r3release      . NEW-LINE.
*      WRITE lwa_attributes-typesrc_leng   . NEW-LINE.
*      WRITE lwa_attributes-typesrc        . NEW-LINE.
    ENDLOOP.

    DATA lwa_method TYPE seoo_method_r.
    WRITE: &apos;Methods&apos; COLOR 3. NEW-LINE.
    LOOP AT me-&gt;methods INTO lwa_method.
      WRITE lwa_method-cmpname. NEW-LINE.
    ENDLOOP.
    ULINE.

  ENDMETHOD.                    &quot;ZIF_WB_OBJECT~WRITE</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_CLASS" CMPNAME="GET_DIRECT_IMPLEMENTATIONS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_CLASS" CMPNAME="GET_DIRECT_IMPLEMENTATIONS" SCONAME="RE_T_DIRECT_IMPLEMENTATIONS" VERSION="1" LANGU="E" DESCRIPT="Copy of standard table type SEO_CLASS_NAMES" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZSEO_CLASS_NAMES"/>
   <source>METHOD get_direct_implementations.
    FIELD-SYMBOLS &lt;implemented_interface&gt; TYPE seor_implementing_r.
    DATA lwa_direct_implementation TYPE seoclass.

    LOOP AT me-&gt;implementings ASSIGNING &lt;implemented_interface&gt;.
      lwa_direct_implementation = &lt;implemented_interface&gt;-refclsname.
      APPEND lwa_direct_implementation TO re_t_direct_implementations.
    ENDLOOP.

  ENDMETHOD.                    &quot;get_direct_implementations</source>
  </method>
  <method CLSNAME="ZCL_WB_CLASS" CMPNAME="LOAD_SUBCLASSES" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD load_subclasses.

  ENDMETHOD.                    &quot;load_subclasses</source>
  </method>
 </CLAS>
 <INTF CLSNAME="ZIF_WB_OBJECT" VERSION="1" LANGU="E" DESCRIPT="Workbench Object" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <typeUsage CLSNAME="ZIF_WB_OBJECT" TYPEGROUP="SABOO" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <typeUsage CLSNAME="ZIF_WB_OBJECT" TYPEGROUP="SEOK" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <typeUsage CLSNAME="ZIF_WB_OBJECT" TYPEGROUP="SEOX" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <attribute CLSNAME="ZIF_WB_OBJECT" CMPNAME="OBJECT" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TADIR-OBJECT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_WB_OBJECT" CMPNAME="OBJ_NAME" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TADIR-OBJ_NAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_WB_OBJECT" CMPNAME="PGMID" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TADIR-PGMID" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZIF_WB_OBJECT" CMPNAME="LOAD" VERSION="1" LANGU="E" DESCRIPT="Load wb objects details" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <exception CLSNAME="ZIF_WB_OBJECT" CMPNAME="LOAD" SCONAME="ZCX_WB_OBJECTS" VERSION="1" LANGU="E" DESCRIPT="WB Objects generic exception" MTDTYPE="0" EDITORDER="1 "/>
  </method>
  <method CLSNAME="ZIF_WB_OBJECT" CMPNAME="TO_STRING" VERSION="1" LANGU="E" DESCRIPT="Get string representation of object" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_WB_OBJECT" CMPNAME="TO_STRING" SCONAME="RE_STRING" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  </method>
  <method CLSNAME="ZIF_WB_OBJECT" CMPNAME="WRITE" VERSION="1" LANGU="E" DESCRIPT="Write representation of object" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0"/>
 </INTF>
 <PROG NAME="Z_WB_SCANNER_OBJECTS_TEST" VARCL="X" SUBC="1" RMAND="800" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Program Z_WB_SCANNER_OBJECTS_TEST" LENGTH="33 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  Z_WB_SCANNER_OBJECTS_TEST
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

REPORT  z_wb_scanner_objects_test.

TYPE-POOLS saboo.
*----------------------------------------------------------------------*
*       CLASS lcl_a DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_a DEFINITION.

  PUBLIC SECTION.
    METHODS constructor.

  PROTECTED SECTION.
    DATA att TYPE c.
ENDCLASS.                    &quot;lcl_a DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_a IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_a IMPLEMENTATION.

  METHOD constructor.

  ENDMETHOD.                    &quot;constructor

ENDCLASS.                    &quot;lcl_a IMPLEMENTATION




PARAMETERS p_incl TYPE programm DEFAULT &apos;ZWB_LOCAL_CLASS_EXAMPLE&apos;.

START-OF-SELECTION.


*  DATA o_wb_scanner TYPE REF TO zcl_wb_scanner_objects.
*
*  DATA t_source_code TYPE saboo_sourt.
*
*  READ REPORT p_incl INTO t_source_code.
*
*  zcl_wb_scanner_objects=&gt;create(
*    IMPORTING
*      scanner = o_wb_scanner
*    CHANGING
*      sourc_tab = t_source_code  ).
*
*
** | [---&gt;] CLSNAME                        TYPE        SEOCLASS-CLSNAME(optional)
** | [---&gt;] SUPERCLSNAME                   TYPE        SEOCLASS-CLSNAME(optional)
** | [---&gt;] EXPOSURE                       TYPE        VSEOCLASS-EXPOSURE (default =2)
** | [&lt;-()] VSEO_TABS                      TYPE        SABOO_VSEOT
*  DATA vl_saboo_vseot TYPE saboo_vseot.
*
*  vl_saboo_vseot = o_wb_scanner-&gt;scan_source( ).

  DATA t_r_local_class TYPE zcl_wb_class_local=&gt;t_r_local_classes.
  DATA r_local_class   TYPE REF TO zcl_wb_class_local.

  t_r_local_class = zcl_wb_class_local=&gt;load_all_classes( p_incl ).

  LOOP AT t_r_local_class INTO r_local_class.
    r_local_class-&gt;zif_wb_object~load( ).
    r_local_class-&gt;to_string( ).
  ENDLOOP.

  &quot;BREAK-POINT.</source>
 </PROG>
 <PROG NAME="ZWB_SCANNER_OBJECTS_TEST" VARCL="X" SUBC="1" RMAND="800" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Program Z_WB_SCANNER_OBJECTS_TEST" LENGTH="33 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  Z_WB_SCANNER_OBJECTS_TEST
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

REPORT  zwb_scanner_objects_test.

PARAMETERS p_incl TYPE programm DEFAULT &apos;ZWB_LOCAL_CLASS_EXAMPLE&apos;.

START-OF-SELECTION.

  DATA t_r_local_class  TYPE ztt_wb_class_local.
  DATA r_local_class    TYPE REF TO zcl_wb_class_local.
  DATA vl_string        TYPE string.
  t_r_local_class = zcl_wb_class_local=&gt;load_all_classes( p_incl ).

  LOOP AT t_r_local_class INTO r_local_class.
    r_local_class-&gt;zif_wb_object~load( ).
    vl_string = r_local_class-&gt;zif_wb_object~to_string( ).
    WRITE vl_string.
    NEW-LINE.
  ENDLOOP.</source>
 </PROG>
 <PROG NAME="ZWB_OBJECTS_DEMO6" VARCL="X" DBAPL="S" SUBC="1" RMAND="001" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="WB Collections" LENGTH="14 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZWB_OBJECTS_DEMO6
*&amp; Title: WB Collections
*&amp; Creator: Fabio Pagoti
*&amp;---------------------------------------------------------------------*
*&amp; This report shows how a very basic usage of WB collections
*&amp;
*&amp; It might worth dealing with WB objects inside the same data structure.
*&amp; In order to accomplish that, WB Objects Framework comes with
*&amp; very simple collection hierarchy.
*&amp;
*&amp; Enjoy!
*&amp;---------------------------------------------------------------------*

REPORT  zwb_objects_demo6.

DATA r_wb_objects TYPE REF TO zcl_wb_set_itab.

CREATE OBJECT r_wb_objects.

DATA r_class TYPE REF TO zcl_wb_class_global.
DATA wa_clskey TYPE seoclskey.

wa_clskey-clsname = &apos;CL_GUI_ALV_GRID&apos;.
CREATE OBJECT r_class
  EXPORTING
    im_clskey                    = wa_clskey
*   im_version                   = SEOC_VERSION_INACTIVE
*   im_state                     = &apos;1&apos;
*   im_with_descriptions         = SEOX_TRUE
*   im_resolve_eventhandler_info = SEOX_FALSE
*   im_with_master_language      = SEOX_FALSE
*   im_with_enhancements         = SEOX_FALSE
*   im_read_active_enha          = SEOX_FALSE
*   im_enha_action               = SEOX_FALSE
*   im_ignore_switches           = &apos;X&apos;
  .

APPEND r_class TO r_wb_objects-&gt;zif_wb_set_itab~t_wb_objects.

DATA r_interface TYPE REF TO zcl_wb_interface_global.

wa_clskey-clsname = &apos;IF_DRAGDROP&apos;.
CREATE OBJECT r_interface
  EXPORTING
    im_intkey               = wa_clskey
*   im_version              = SEOC_VERSION_INACTIVE
*   im_state                = &apos;1&apos;
*   im_with_master_language = SEOX_FALSE
*   im_with_enhancements    = SEOX_FALSE
*   im_read_active_enha     = SEOX_FALSE
*   im_enha_action          = SEOX_FALSE
*   im_ignore_switches      = &apos;X&apos;
  .

APPEND r_interface TO r_wb_objects-&gt;zif_wb_set_itab~t_wb_objects.

DATA r_wb_object TYPE REF TO zif_wb_object.
DATA v_to_string TYPE string.
LOOP AT r_wb_objects-&gt;zif_wb_set_itab~t_wb_objects INTO r_wb_object.
  TRY.
      r_wb_object-&gt;load( ).
    CATCH zcx_wb_objects.    &quot; WB Objects generic exception
  ENDTRY.
  v_to_string = r_wb_object-&gt;to_string( ).
  WRITE v_to_string. NEW-LINE.
ENDLOOP.</source>
 </PROG>
 <PROG NAME="ZWB_OBJECTS_DEMO5" VARCL="X" DBAPL="S" SUBC="1" RMAND="001" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Mass loader (based on searcher)" LENGTH="31 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZWB_OBJECTS_DEMO5
*&amp; Title: Mass loader (based on searcher)
*&amp; Creator: Fabio Pagoti
*&amp;---------------------------------------------------------------------*
*&amp; This report shows how to automatically load WB objects based on a WB searcher.
*&amp;
*&amp; To know learn about WB Searchers, check ZWB_OBJECTS_DEMO3 and project documentation.
*&amp;
*&amp; In this demo, ZWB_OBJECTS_DEMO3 is improved to print more data of a range of classes
*&amp; Still, classes to be printed are found using a WB Searched.
*&amp; The difference is that after having a search result, we automatically load
*&amp; WB instances using what is called Mass Loader. This process can be
*&amp; considered an evolution of ZWB_OBJECTS_DEMO4, where we manually load
*&amp; each instance one by one.
*&amp;
*&amp; In other words, after the search for classes is completed, we take
*&amp; a WB searcher result to lead each result in a different WB instance, no matter
*&amp; what it the right type for it.
*&amp; Then, after all search results are loaded, we can print more details about each one
*&amp; (in this exemple, its attributes and methods of classes)
*&amp;
*&amp; Notice that we have many instance of ZCL_WB_CLASS_GLOBAL at the same time once we
*&amp; &apos;mass load&apos; a search result. Different than ZWB_OBJECTS_DEMO4, we just iterate
*&amp; through the loaded instances to print what is needed
*&amp;
*&amp; Enjoy!
*&amp;---------------------------------------------------------------------*

REPORT  zwb_objects_demo5.

DATA v_class TYPE zcl_wb_searcher=&gt;ty_class-clsname.

SELECT-OPTIONS: s_class FOR v_class MATCHCODE OBJECT sfbeclname.

*******************************************
* INITIALIZATION
*******************************************
INITIALIZATION.
  s_class-low = &apos;ZCL_WB*&apos;.
  s_class-sign = &apos;I&apos;.
  s_class-option = &apos;CP&apos;.
  APPEND s_class.

*******************************************
* START-OF-SELECTION
*******************************************
START-OF-SELECTION.

  DATA r_wb_searcher TYPE REF TO zif_wb_searcher. &quot; Generic searcher
  DATA r_wb_search_criteria TYPE REF TO zcl_wb_search_criteria. &quot; A search criteria is a filter defined by many range objects

  r_wb_search_criteria ?= zcl_wb_search_criteria=&gt;zif_wb_search_criteria~factory(
      im_classes =  s_class[] &quot;
  ).

  CREATE OBJECT r_wb_searcher
    TYPE zcl_wb_searcher &quot; ZCL_WB_SEARCHER is capable of searching any WB object but only search its name + description
    EXPORTING
      im_r_wb_search_criteria = r_wb_search_criteria.

  &quot; you can use the other search criterias for the same searcher. In this case, we use the same
  r_wb_searcher-&gt;search_wb_objects( im_wb_search_criteria = r_wb_searcher-&gt;r_wb_search_criteria ).


  DATA r_wb_mass_loader TYPE REF TO zif_wb_mass_loader. &quot; Generic mass loader - a mass loader can be based on anything
  DATA r_wb_full_mass_loader TYPE REF TO zcl_wb_mass_loader_searcher. &quot; Full mass loader - This mass loader is based on a WB Searcher

  CREATE OBJECT r_wb_mass_loader
    TYPE zcl_wb_mass_loader_searcher
    EXPORTING
      im_r_wb_searcher = r_wb_searcher. &quot; Searcher already contains search results.

  r_wb_full_mass_loader ?= r_wb_mass_loader.

  DATA r_wb_objects_loaded TYPE REF TO zcl_wb_set_itab. &quot; Object which will store WB objects loaded
  r_wb_objects_loaded ?= r_wb_full_mass_loader-&gt;zif_wb_mass_loader~mass_load( ). &quot; Magic happens: each search result is converted into a WB object instance

  DATA r_wb_object TYPE REF TO zif_wb_object.
  DATA r_wb_class TYPE REF TO zcl_wb_class_global.

  LOOP AT r_wb_objects_loaded-&gt;zif_wb_set_itab~t_wb_objects INTO r_wb_object. &quot; Loop is NOT on the search result anymore but on the result from mass loader (a collection)

    r_wb_class ?= r_wb_object. &quot; A collection might have any kind of WB Object. In this case we know that there are just classes

    FORMAT COLOR COL_POSITIVE.
    WRITE: &apos;Class:&apos;, r_wb_class-&gt;class-clsname.
    NEW-LINE.
    FORMAT RESET.

    FORMAT COLOR COL_GROUP.
    WRITE: &apos;Attributes&apos;. NEW-LINE.
    FORMAT RESET.
    DATA wa_attribute LIKE LINE OF r_wb_class-&gt;attributes.
    LOOP AT r_wb_class-&gt;attributes INTO wa_attribute.
      WRITE: AT 5 wa_attribute-cmpname. NEW-LINE.
    ENDLOOP.


    FORMAT COLOR COL_HEADING.
    WRITE: &apos;Methods&apos;. NEW-LINE.
    FORMAT RESET.
    DATA wa_method LIKE LINE OF r_wb_class-&gt;methods.
    LOOP AT r_wb_class-&gt;methods INTO wa_method.
      WRITE: AT 5 wa_method-cmpname. NEW-LINE.
    ENDLOOP.

    ULINE.

  ENDLOOP.</source>
 </PROG>
 <PROG NAME="ZWB_OBJECTS_DEMO4" VARCL="X" DBAPL="S" SUBC="1" RMAND="001" RLOAD="E" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Manual Load (based on searcher)" LENGTH="31 "/>
   </language>
  </textPool>
  <source>REPORT  zwb_objects_demo4.

DATA v_class TYPE zcl_wb_searcher=&gt;ty_class-clsname.

SELECT-OPTIONS: s_class FOR v_class MATCHCODE OBJECT sfbeclname.

*******************************************
* INITIALIZATION
*******************************************
INITIALIZATION.
  s_class-low = &apos;ZCL_WB*&apos;.
  s_class-sign = &apos;I&apos;.
  s_class-option = &apos;CP&apos;.
  APPEND s_class.

*******************************************
* START-OF-SELECTION
*******************************************
START-OF-SELECTION.

  DATA r_wb_searcher TYPE REF TO zif_wb_searcher. &quot; Generic searcher
  DATA r_wb_search_criteria TYPE REF TO zcl_wb_search_criteria. &quot; A search criteria is a filter defined by many range objects

  r_wb_search_criteria ?= zcl_wb_search_criteria=&gt;zif_wb_search_criteria~factory(
      im_classes =  s_class[] &quot;
  ).

  CREATE OBJECT r_wb_searcher
    TYPE zcl_wb_searcher &quot; ZCL_WB_SEARCHER is capable of searching any WB object but only search its name + description
    EXPORTING
      im_r_wb_search_criteria = r_wb_search_criteria.

  &quot; you can use the other search criterias for the same searcher. In this case, we use the same
  r_wb_searcher-&gt;search_wb_objects( im_wb_search_criteria = r_wb_searcher-&gt;r_wb_search_criteria ).


  DATA r_wb_full_searcher TYPE REF TO zcl_wb_searcher.

  r_wb_full_searcher ?= r_wb_searcher. &quot; Downcasting to access search results
  DATA wa_class TYPE zcl_wb_searcher=&gt;ty_class.
  DATA r_wb_class TYPE REF TO zcl_wb_class_global.
  DATA wa_clskey TYPE seoclskey.

  LOOP AT r_wb_full_searcher-&gt;t_classes INTO wa_class.
    wa_clskey-clsname = wa_class-clsname.

    CREATE OBJECT r_wb_class
      EXPORTING
        im_clskey = wa_clskey.
    TRY.
        r_wb_class-&gt;zif_wb_object~load( ).
      CATCH zcx_wb_objects.    &quot; WB Objects generic exception
    ENDTRY.

    FORMAT COLOR COL_POSITIVE.
    WRITE: &apos;Class:&apos;, r_wb_class-&gt;class-clsname.
    NEW-LINE.
    FORMAT RESET.

    FORMAT COLOR COL_GROUP.
    WRITE: &apos;Attributes&apos;. NEW-LINE.
    FORMAT RESET.
    DATA wa_attribute LIKE LINE OF r_wb_class-&gt;attributes.
    LOOP AT r_wb_class-&gt;attributes INTO wa_attribute.
      WRITE: AT 5 wa_attribute-cmpname. NEW-LINE.
    ENDLOOP.


    FORMAT COLOR COL_HEADING.
    WRITE: &apos;Methods&apos;. NEW-LINE.
    FORMAT RESET.
    DATA wa_method LIKE LINE OF r_wb_class-&gt;methods.
    LOOP AT r_wb_class-&gt;methods INTO wa_method.
      WRITE: AT 5 wa_method-cmpname. NEW-LINE.
    ENDLOOP.

    ULINE.

  ENDLOOP.</source>
 </PROG>
 <PROG NAME="ZWB_OBJECTS_DEMO3" VARCL="X" DBAPL="S" SUBC="1" RMAND="001" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="WB Searcher" LENGTH="11 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZWB_OBJECTS_DEMO3
*&amp; Title: WB Searcher
*&amp; Creator: Fabio Pagoti
*&amp;---------------------------------------------------------------------*
*&amp; This report shows how to use WB objects search capability.
*&amp;
*&amp; In order to create a WB object instance which represents a workbench object,
*&amp; you must know object&apos;s full name. Usually this name is passed inside the
*&amp; constructor of a class and it is used to get all objects details using
*&amp; helper classes, function modules and even SELECT statements.
*&amp;
*&amp; What if you don&apos;t know the full name of a global class to be loaded?
*&amp; Maybe you just know that it starts with ZCL_WB*.
*&amp; Or maybe you actually want to know all classes matching this name!
*&amp;
*&amp; Fortunately, ABAP Workbench Objects Framework contains a search
*&amp; mechanism known as WB Searchers. As its name implies, WB searchers
*&amp; are responsible for searching workbench objects in the system according
*&amp; to some search criteria. Search criterias are basically ranges (or
*&amp; select-options) for workbench objects properties, usually their names.
*&amp;
*&amp; WB searchers saves you from coding a logic to know all possible
*&amp; classes which names follow a specific patterns and doing the same all
*&amp; over again for interfaces, domains, data elements, programs, includes,
*&amp; tables, views and so on.
*&amp;
*&amp; Notice that using ABAP Workbench Objects Framework, you do not need to
*&amp; worry about where and how exactly workbench objects are saved in the
*&amp; system. There is no need to use SELECT statements looking for data
*&amp; from classes and interfaces.
*&amp;
*&amp; Notice that WB Searchers are just responsible for select the names
*&amp; of workbench objects according to a search criteria. Using a WB
*&amp; Searcher you don&apos;t have references for WB references automatically.
*&amp; You can have it using a different concept called WB mass loader,
*&amp; which is a topic for a future demo. For now, understand that
*&amp; a WB Searcher is the first step you will need to know if you want
*&amp; to represent more than one WB object using an OO approach.
*&amp;
*&amp; Enjoy!
*&amp;---------------------------------------------------------------------*

REPORT  zwb_objects_demo3.

DATA v_class TYPE zcl_wb_searcher=&gt;ty_class-clsname.
SELECT-OPTIONS: s_class FOR v_class MATCHCODE OBJECT sfbeclname. &quot; Search criteria for a global class

*******************************************
* INITIALIZATION
*******************************************
INITIALIZATION.
  s_class-low = &apos;ZCL_WB*&apos;. &quot; just creating a default search criteria patterns, to save you a few keystrokes
  s_class-sign = &apos;I&apos;.
  s_class-option = &apos;CP&apos;.
  APPEND s_class.

*******************************************
* START-OF-SELECTION
*******************************************
START-OF-SELECTION.

  DATA r_wb_searcher TYPE REF TO zif_wb_searcher. &quot; Generic searcher
  DATA r_wb_search_criteria TYPE REF TO zcl_wb_search_criteria. &quot; A search criteria is a filter defined by many range objects

  r_wb_search_criteria ?= zcl_wb_search_criteria=&gt;zif_wb_search_criteria~factory(
      im_classes =  s_class[] &quot; When we create a search criteria object, we can pass many ranges all at once.
                              &quot; Each one will represent a search criteria for each WB object.
                              &quot; Consider checking optional parameters of this factory method. They were removed as they are not used in this demo
  ).


* At this point we have a search criteria object created. We don&apos;t need to do anything else with it. It is just a way to use some dependency injection
* in a WB searcher object

  CREATE OBJECT r_wb_searcher
    TYPE zcl_wb_searcher &quot; ZCL_WB_SEARCHER is capable of searching any WB object but only search its name
    EXPORTING
      im_r_wb_search_criteria = r_wb_search_criteria.

  &quot; you can use other search criteria for the same searcher. In this case, we use the same
  r_wb_searcher-&gt;search_wb_objects( im_wb_search_criteria = r_wb_searcher-&gt;r_wb_search_criteria ).


  DATA r_wb_full_searcher TYPE REF TO zcl_wb_searcher.

  r_wb_full_searcher ?= r_wb_searcher. &quot; Downcasting to access search results


* Notice that a WB Searcher only retrieves some specific data (in this case, WB object&apos;s name).
* The advantage of using a WB Searcher is that we now know how many classes matches our search pattern and who they are
  DATA wa_class TYPE zcl_wb_searcher=&gt;ty_class.
  LOOP AT r_wb_full_searcher-&gt;t_classes INTO wa_class.
    WRITE wa_class-clsname.
    NEW-LINE.
  ENDLOOP.</source>
 </PROG>
 <PROG NAME="ZWB_OBJECTS_DEMO1" VARCL="X" SUBC="1" RSTAT="T" RMAND="001" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Classes and interfaces (globals and locals)" LENGTH="43 "/>
    <textElement ID="S" KEY="P_CLASS" ENTRY="        Global Class" LENGTH="20 "/>
    <textElement ID="S" KEY="P_INTER" ENTRY="        Global Interface" LENGTH="24 "/>
    <textElement ID="S" KEY="P_REPOR" ENTRY="        Program/Include Name" LENGTH="28 "/>
   </language>
  </textPool>
  <programDocumentation OBJECT="ZWB_OBJECTS_DEMO1">
   <language SPRAS="E">
    <textLine TDFORMAT="U1" TDLINE="&amp;PURPOSE&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDLINE="This is a demo program to show how to use WB Objects Framework. In this"/>
    <textLine TDLINE="demo, user can insert the name of Global Class, Global Interface or a"/>
    <textLine TDLINE="program/include name. WB Objects will retrieve data from each object"/>
    <textLine TDLINE="according to its type and write some of the information in the screen"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U1" TDLINE="&amp;INTEGRATION&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U1" TDLINE="&amp;PREREQUISITES&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U1" TDLINE="&amp;FEATURES&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U2" TDLINE="&amp;SELECTION&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U2" TDLINE="&amp;STANDARD_VARIANTS&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U2" TDLINE="&amp;OUTPUT&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U1" TDLINE="&amp;ACTIVITIES&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U1" TDLINE="&amp;EXAMPLE&amp;"/>
    <textLine TDFORMAT="AS"/>
   </language>
  </programDocumentation>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZWB_OBJECTS_DEMO1
*&amp; Title: Classes and interfaces (globals and locals)
*&amp; Creator: Fabio Pagoti
*&amp;---------------------------------------------------------------------*
*&amp; This report shows how some WB objects can be loaded into memory
*&amp; Here, it&apos;s possible to load
*&amp; 1) A global class
*&amp; 2) A global interface
*&amp; 3) All local classes and interfaces from a program/include
*&amp;
*&amp; Notice that using ABAP Objects Workbench Framework, you do not need to
*&amp; worry about where and how exactly workbench objects are saved in the
*&amp; system. There is no need to use SELECT statements looking for data
*&amp; from classes and interfaces.
*&amp;
*&amp; All you need to know is which WB Object class represents each
*&amp; ABAP Workbench object. Then, you can use method ZIF_WB_OBJECT~LOAD
*&amp; to retrieve all data from that specific workbench object and use it
*&amp; as needed.
*&amp;
*&amp; Enjoy!
*&amp;---------------------------------------------------------------------*

REPORT  zwb_objects_demo1.

PARAMETERS p_class TYPE seoclass-clsname DEFAULT &apos;CL_SALV_TABLE&apos;. &quot; Global Class
PARAMETERS p_inter TYPE seoclass-clsname. &quot; Global Interface
PARAMETERS p_repor TYPE reposrc-progname. &quot; Program/Include - will be used to load all local classes and interfaces

AT SELECTION-SCREEN.

  IF &quot; If everything is filled or nothing is filled, show a message
     (  p_class IS NOT INITIAL AND
        p_inter IS NOT INITIAL AND
        p_repor IS NOT INITIAL ) OR

     (  p_class IS INITIAL AND
        p_inter IS INITIAL AND
        p_repor IS INITIAL )
        .
    MESSAGE &apos;Fill a class or an interface or a report name&apos; TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
  ENDIF.


START-OF-SELECTION.

  DATA o_class TYPE REF TO zcl_wb_class. &quot; This reference represents an ABAP Class (no matter if it global or local yet)

* Global Class
  IF p_class IS NOT INITIAL.

    DATA o_global_class TYPE REF TO zcl_wb_class_global. &quot; This reference represents an ABAP GLOBAL Class
    DATA wa_seoclskey TYPE seoclskey.

    wa_seoclskey-clsname = p_class.
    CREATE OBJECT o_global_class
      EXPORTING
        im_clskey                    = wa_seoclskey
*       im_version                   = SEOC_VERSION_INACTIVE
*       im_state                     = &apos;1&apos;
*       im_with_descriptions         = SEOX_TRUE
*       im_resolve_eventhandler_info = SEOX_FALSE
*       im_with_master_language      = SEOX_FALSE
*       im_with_enhancements         = SEOX_FALSE
*       im_read_active_enha          = SEOX_FALSE
*       im_enha_action               = SEOX_FALSE
*       im_ignore_switches           = &apos;X&apos;
      .

    TRY .
        o_global_class-&gt;zif_wb_object~load( ). &quot; Using zif_wb_object~load method, all details from the class (atributes, methods, methods parameters, events and so on are loaded into the object
      CATCH zcx_wb_class_dont_exist.
        MESSAGE &apos;This class do not exist&apos; TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
        STOP.
      CATCH zcx_wb_is_interface.
        MESSAGE &apos;This value informed is actually an interface&apos; TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
        STOP.
      CATCH zcx_wb_class_is_model_only.
        MESSAGE &apos;This class is only a model&apos; TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
        STOP.
      CATCH zcx_wb_objects.    &quot; WB Objects generic exception
        MESSAGE &apos;Unknow error when loading the global class&apos; TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos; .
        STOP.
    ENDTRY.

    o_global_class-&gt;zif_wb_object~write( ). &quot; Write class details
    STOP.

  ENDIF.


* Global Interface
  IF p_inter IS NOT INITIAL.

    DATA o_global_interface TYPE REF TO zcl_wb_interface_global. &quot; This reference represents a GLOBAL interface
    DATA wa_intkey TYPE seoclskey.

    wa_intkey-clsname = p_inter.

    CREATE OBJECT o_global_interface
      EXPORTING
        im_intkey               = wa_intkey
*       im_version              = SEOC_VERSION_INACTIVE
*       im_state                = &apos;1&apos;
*       im_with_master_language = SEOX_FALSE
*       im_with_enhancements    = SEOX_FALSE
*       im_read_active_enha     = SEOX_FALSE
*       im_enha_action          = SEOX_FALSE
*       im_ignore_switches      = &apos;X&apos;
      .

    TRY .
        o_global_interface-&gt;zif_wb_object~load( ). &quot; Again, method zif_wb_object~load is used to retrive all data from a WB object. As this is an interface, all attributes, methods definitions, events etc are loaded inside object reference
      CATCH zcx_wb_interface_dont_exist.
        MESSAGE &apos;This interface do not exist&apos; TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
        STOP.
      CATCH zcx_wb_is_interface.
        MESSAGE &apos;This value informed is actually a class&apos; TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
        STOP.
      CATCH zcx_wb_class_is_model_only.
        MESSAGE &apos;This interface is only a model&apos; TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
        STOP.
      CATCH zcx_wb_objects.    &quot; WB Objects generic exception
        MESSAGE &apos;Unknow error when loading the global interface&apos; TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos; .
        STOP.
    ENDTRY.

    o_global_interface-&gt;zif_wb_object~write( ). &quot; Write interface details
    STOP.
  ENDIF.


* Program/Include
  IF p_repor IS NOT INITIAL.

    DATA itab_local_class TYPE ztt_wb_class_local. &quot; A table type of local classes references
    DATA o_local_class TYPE REF TO zcl_wb_class_local. &quot; A single reference for a local class

* Local classes
    TRY .
        itab_local_class = zcl_wb_class_local=&gt;load_all_classes( im_program = p_repor ). &quot; Given a program/include, retrieves and loads all its local classes
      CATCH zcx_wb_report_dont_exist.
        MESSAGE &apos;This program/include do not exist&apos; TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos; .
        STOP.
      CATCH zcx_wb_report_without_class.
        WRITE: &apos;There is no local classes&apos;.
        NEW-LINE.
    ENDTRY.

    LOOP AT itab_local_class INTO o_local_class. &quot; As the same program/include might have more than one local class, we can loop over them and ask each object to write its details
      o_local_class-&gt;zif_wb_object~write( ).
    ENDLOOP.



* Local interfaces
    DATA itab_local_interface TYPE ztt_wb_interface_local. &quot; A table type of local interface references
    DATA o_local_interface TYPE REF TO zcl_wb_interface_local. &quot; A single reference for a local interface

    TRY .
        itab_local_interface = zcl_wb_interface_local=&gt;load_all_interfaces( im_program = p_repor ). &quot; Given a program/include, retrieves and loads all its local interfaces
      CATCH zcx_wb_report_dont_exist.
        MESSAGE &apos;This program/include do not exist&apos; TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos; .
        STOP.
      CATCH zcx_wb_report_without_inter.
        WRITE: &apos;There is no local interfaces&apos;.
        NEW-LINE.
    ENDTRY.

    LOOP AT itab_local_interface INTO o_local_interface. &quot; As the same program/include might have more than one local interface, we can loop over them and ask each object to write its details
      o_local_interface-&gt;zif_wb_object~to_string( ).
    ENDLOOP.

    STOP.
  ENDIF.</source>
 </PROG>
 <PROG NAME="ZWB_LOCAL_CLASS_EXAMPLE" VARCL="X" SUBC="I" RMAND="800" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="ZWB_LOCAL_CLASS_EXAMPLE" LENGTH="23 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           ZWB_LOCAL_CLASS_EXAMPLE
*&amp;---------------------------------------------------------------------*

INTERFACE lif_intf_1.
  DATA aaa TYPE i.
  DATA bbb TYPE c.

  METHODS do_1.
  METHODS do_2
    IMPORTING
      im_aaa TYPE i.

  METHODS do_3
    IMPORTING
      im_iii TYPE i
    RETURNING VALUE(re_bbb) TYPE char2.

ENDINTERFACE.


CLASS lcl_class_1 DEFINITION.

  PUBLIC SECTION.
    METHODS constuctor.


  PROTECTED SECTION.
    DATA att_1 TYPE i.

  PRIVATE SECTION.

    METHODS do_something
      IMPORTING
        im_fp TYPE i.

ENDCLASS.                    &quot;lcl_class_1 DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_class_1 IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_class_1 IMPLEMENTATION.

  METHOD constuctor.
    att_1 = im_fp.
  ENDMETHOD.                    &quot;constuctor

  METHOD do_something.
    WAIT UP TO 1 SECONDS.
  ENDMETHOD.                    &quot;do_something
ENDCLASS.                    &quot;lcl_class_1 IMPLEMENTATION


*----------------------------------------------------------------------*
*       CLASS lcl_class_2 DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_class_2 DEFINITION INHERITING FROM lcl_class_1.
  PUBLIC SECTION.
  DATA att_2 TYPE string.
  PRIVATE SECTION.
  METHODS do_something REDEFINITION.
ENDCLASS.                    &quot;lcl_class_2 DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_class_2 IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_class_2 IMPLEMENTATION.
  METHOD do_something.
    WAIT UP TO me-&gt;att_1 SECONDS.
  ENDMETHOD.                    &quot;do_something

ENDCLASS.                    &quot;lcl_class_2 IMPLEMENTATION


CLASS lcl_class_3 DEFINITION..
  DATA aaa TYPE i.
  DATA bbb TYPE c.

  METHODS do_1.
  METHODS do_2
    IMPORTING
      im_aaa TYPE i.

  METHODS do_3
    IMPORTING
      im_iii TYPE i
    RETURNING VALUE(re_bbb) TYPE c.

ENDCLASS.</source>
 </PROG>
 <PROG NAME="ZI_ZCL_WB_CLASS_LOCAL_STUB" VARCL="X" SUBC="I" APPL="S" RMAND="001" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include ZI_ZCL_WB_CLASS_LOCAL_STUB" LENGTH="34 "/>
   </language>
  </textPool>
  <source>*----------------------------------------------------------------------*
*       CLASS lcl_wb_class_local_stub DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_wb_class_local_stub DEFINITION.
  PUBLIC SECTION.

    CLASS-METHODS create_class_name
      RETURNING value(re_class_name) TYPE seoclsname.

    CLASS-METHODS create_vseo_tabs_class
      RETURNING value(re_t_vseo_tabs_class) TYPE saboo_vseot-class_tab.

ENDCLASS.                    &quot;lcl_wb_class_local_stub DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_wb_class_local_stub IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_wb_class_local_stub IMPLEMENTATION.

  METHOD create_class_name.
    re_class_name = &apos;CLSNAME&apos;.
  ENDMETHOD.                    &quot;create_class_name


  METHOD create_vseo_tabs_class.
    DATA lwa_vseo_class TYPE vseoclass.
    lwa_vseo_class-clsname = lcl_wb_class_local_stub=&gt;create_class_name( ).
*    lwa_vseo_class-version
*    lwa_vseo_class-langu
*    lwa_vseo_class-descript
*    lwa_vseo_class-uuid
*    lwa_vseo_class-category
*    lwa_vseo_class-exposure
*    lwa_vseo_class-state
*    lwa_vseo_class-release
*    lwa_vseo_class-author
*    lwa_vseo_class-createdon
*    lwa_vseo_class-changedby
*    lwa_vseo_class-changedon
*    lwa_vseo_class-chgdanyby
*    lwa_vseo_class-chgdanyon
*    lwa_vseo_class-clsembed
*    lwa_vseo_class-clsabstrct
*    lwa_vseo_class-clsfinal
*    lwa_vseo_class-clsccincl
*    lwa_vseo_class-remote
*    lwa_vseo_class-fixpt
*    lwa_vseo_class-varcl
*    lwa_vseo_class-unicode
*    lwa_vseo_class-rstat
*    lwa_vseo_class-clsdefatt
*    lwa_vseo_class-clsdefmtd
*    lwa_vseo_class-clsdefint
*    lwa_vseo_class-clsbcimpl
*    lwa_vseo_class-r3release
*    lwa_vseo_class-clsbctrans
*    lwa_vseo_class-clsbccat
*    lwa_vseo_class-clsaddon
*    lwa_vseo_class-msg_id
*    lwa_vseo_class-clsbcnodel
*    lwa_vseo_class-clsproxy
*    lwa_vseo_class-clssharedmemory
*    lwa_vseo_class-with_unit_tests
*    lwa_vseo_class-duration_type
*    lwa_vseo_class-risk_level
*    lwa_vseo_class-within_package

    APPEND lwa_vseo_class TO re_t_vseo_tabs_class.
  ENDMETHOD.                    &quot;create_vseo_tabs_class
ENDCLASS.                    &quot;lcl_wb_class_local_stub IMPLEMENTATION</source>
 </PROG>
 <PROG NAME="ZI_ZCL_WB_CLASS_LOCAL_MOCK" VARCL="X" SUBC="I" APPL="S" RMAND="001" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include ZI_ZCL_WB_CLASS_LOCAL_MOCK" LENGTH="34 "/>
   </language>
  </textPool>
  <source>*----------------------------------------------------------------------*
*       CLASS lcl_wb_class_local_mock DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_wb_class_local_mock DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS create_att_class
      RETURNING value(re_t_vseo_tabs_class) TYPE saboo_vseot-class_tab.

ENDCLASS.                    &quot;lcl_wb_class_local_mock DEFINITION


*----------------------------------------------------------------------*
*       CLASS lcl_wb_class_local_mock IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_wb_class_local_mock IMPLEMENTATION.
  METHOD create_att_class.

  ENDMETHOD.                    &quot;create_att_class
ENDCLASS.                    &quot;lcl_wb_class_local_mock IMPLEMENTATION</source>
 </PROG>
 <PROG NAME="ZI_ZCL_WB_CLASS_LOCAL_FAKES" VARCL="X" SUBC="I" APPL="S" RMAND="001" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include ZI_ZCL_WB_CLASS_LOCAL_FAKES" LENGTH="35 "/>
   </language>
  </textPool>
  <source>include ZI_ZCL_WB_CLASS_LOCAL_STUB.
include ZI_ZCL_WB_CLASS_LOCAL_MOCK.</source>
 </PROG>
 <PROG NAME="ZIN_WB_SCANNER_OBJECTS" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" LEVL="702" RMAND="000" RLOAD="D" FIXPT="X" LDBNAME="D$S">
  <textPool>
   <language SPRAS="D">
    <textElement ID="R" ENTRY="Include LS_ABAP_OBJECTS_SCANTOP" LENGTH="31 "/>
   </language>
  </textPool>
  <source>INCLUDE ZIN_WB_SCANNER_OBJECTS.

type-pools:
  sana,
  abap,
  saboo.

class statement_illegal definition inheriting from cx_no_check final.
endclass.

class scanner definition final.
  public section.

    constants:
      begin of const,
        max_line_size type i value 255,
        begin of aunit_duration,
          short  type vseoclass-duration_type value 12,
          medium type vseoclass-duration_type value 24,
          long   type vseoclass-duration_type value 36,
        end of aunit_duration,
        begin of aunit_risk,
          harmless  type vseoclass-risk_level value 11,
          dangerous type vseoclass-risk_level value 22,
          critical  type vseoclass-risk_level value 33,
        end of aunit_risk,
        begin of exposure,
          public    type vseoclass-exposure value 2,
          protected type vseoclass-exposure value 1,
          package   type vseoclass-exposure value 3,
          private   type vseoclass-exposure value 0,
        end of exposure,
      end of const.

    class-methods create importing resolve_includes type seox_boolean optional
                         exporting scanner type ref to scanner
                                   error_source type syrepid
                         changing  sourc_tab type saboo_sourt.

    methods scan_source importing clsname type seoclass-clsname optional
                                  superclsname type seoclass-clsname optional
                                  exposure type vseoclass-exposure default 2
                        returning value(vseo_tabs) type saboo_vseot.
    methods scan_source_for_method_impls
                        returning value(method_impls) type saboo_method_impl_tab.

  private section.

    types:
      begin of scope_rec_type,
        clsname      type c length 30,
        superclsname type c length 30,
        is_interface type c length  1,
        exposure     type n length  1,
      end of scope_rec_type,
      scope_sta_type type standard table of scope_rec_type with non-unique key clsname,
*     global fields
      begin of me_priv_type,
*       tables for SCAN
        state_tab type saboo_statt,
        token_tab type saboo_tokstx,
        sourc_tab type saboo_sourt,
*       global state
        clsname      type c length 30,
        superclsname type c length 30,
        is_interface type c length  1,
        cmpname      type c length  61,
        version      type n length  1,
        langu        type c length  1,
        exposure     type n length  1,
        state        type n length  1,
        mtdtype      type n length  1,
*       nested scope stack &amp; counter
        nested_sc type i,
        scope_sta type scope_sta_type,
*       nested BEGIN ... END type declaration
        inside_begin_end type i,
        begin_end_col    type i,
        begin_end_row    type i,
*       counter for editor order
        editor_order type i,
      end of me_priv_type.

    data:
      me_priv type me_priv_type boxed.

    methods reset.

    methods resolve_includes changing sourc_tab type saboo_sourt
                                      error_source type syst-repid.
    methods source_tab_to_char importing typsr_rec type saboo_typsr
                               changing char type c.

    methods insert_class importing state_begin type i
                                   state_end   type i
                         changing  class_tab   type saboo_clast
                                   exted_tab   type saboo_extet
                                   frnds_tab   type saboo_frndt.
    methods insert_inter importing state_pos type i
                         changing  inter_tab type saboo_intet.
    methods insert_attri importing value(attdecltyp) type n
                                   state_begin       type i
                                   state_end         type i
                         changing  attri_tab         type saboo_attrt
                                   typsr_tab         type saboo_typst.
    methods insert_metho importing value(mtddecltyp) type n
                                   state_pos         type i
                                   state_end         type i
                         changing  metho_tab         type saboo_metht
                                   redef_tab         type saboo_redet
                                   mpara_tab         type saboo_mpart
                                   mexce_tab         type saboo_mexct.
    methods insert_event importing value(evtdecltyp) type n
                                   state_pos         type i
                                   state_end         type i
                         changing  event_tab         type saboo_event
                                   epara_tab         type saboo_epart.
    methods insert_iimpl importing state_pos type i
                                   state_end type i
                         changing  iimpl_tab type saboo_iimpt
                                   redef_tab type saboo_redet.
    methods insert_types importing state_begin type i
                                   state_end   type i
                         changing  types_tab   type saboo_typet
                                   typsr_tab   type saboo_typst.
    methods insert_iincl importing state_pos type i
                         changing  iincl_tab type saboo_iinct.
    methods insert_alias importing state_pos type i
                                   state_end type i
                         changing  alias_tab type saboo_aliat.
    methods insert_cload importing state_pos type i
                         changing  cload_tab type saboo_cloat.
    methods insert_iload importing state_pos type i
                         changing  iload_tab type saboo_iloat.
    methods insert_tpool importing state_pos type i
                         changing  tpool_tab type saboo_tpoot.
    methods insert_frnds importing clsname   type csequence
                                   state_pos type i
                                   state_end type i
                         changing  frnds_tab type saboo_frndt.
    methods insert_mpara importing state_end type i
                         changing  curre_pos type i
                                   mpara_tab type saboo_mpart.
    methods insert_mexec importing state_end type i
                         changing  curre_pos type i
                                   mtdnewexc type seonewexc
                                   mexce_tab type saboo_mexct.
    methods insert_epara importing state_end type i
                         changing  curre_pos type i
                                   epara_tab type saboo_epart.
    methods write_mpara importing value(pardecltyp) type n
                                  state_end         type i
                        changing  curre_pos         type i
                                  mpara_tab         type saboo_mpart.
    methods write_epara importing value(pardecltyp) type n
                                  state_end         type i
                        changing  curre_pos         type i
                                  epara_tab         type saboo_epart.


endclass.</source>
 </PROG>
 <TABL TABNAME="ZDD43V" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Copy of structure DD43V" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZDD43V" FIELDNAME="TYPENAME" DDLANGUAGE="E" POSITION="0001" ROLLNAME="TTYPENAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="TTYPENAME" ROUTPUTLEN="000000" MEMORYID="TTYP" HEADLEN="15" SCRLEN1="10" SCRLEN2="18" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD40L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Name of table type" REPTEXT="Table type" SCRTEXT_S="Type name" SCRTEXT_M="Table type name" SCRTEXT_L="Table type name" DOMNAME3L="TTYPENAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDD43V" FIELDNAME="SECKEYNAME" DDLANGUAGE="E" POSITION="0002" ROLLNAME="SECKEYNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="SECKEYNAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="18" SCRLEN3="30" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Name of Secondary Key for Table Type" REPTEXT="Secondary Key" SCRTEXT_S="Sec.Key" SCRTEXT_M="Secondary Key" SCRTEXT_L="Secondary Key" DOMNAME3L="SECKEYNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDD43V" FIELDNAME="DDLANGUAGE" DDLANGUAGE="E" POSITION="0003" ROLLNAME="DDLANGUAGE" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="SPRAS" ROUTPUTLEN="000000" HEADLEN="02" SCRLEN1="07" SCRLEN2="07" SCRLEN3="07" DTELMASTER="D" DATATYPE="LANG" LENG="000001" OUTPUTLEN="000002" DECIMALS="000000" LOWERCASE="X" ENTITYTAB="T002" CONVEXIT="ISOLA" MASK="  LANGE" MASKLEN="0000" DDTEXT="Language Key" REPTEXT="Ln" SCRTEXT_S="Lang." SCRTEXT_M="Lang." SCRTEXT_L="Lang." DOMNAME3L="SPRAS" DEPTH="00" COMPTYPE="E" LANGUFLAG="X" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDD43V" FIELDNAME="SECKEYUNIQUE" DDLANGUAGE="E" POSITION="0004" ROLLNAME="SECKEY_UNIQUE" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="AS4FLAG" ROUTPUTLEN="000000" HEADLEN="10" SCRLEN1="00" SCRLEN2="00" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Indicator for Unique Key" REPTEXT="Unique" SCRTEXT_L="Unique Key" DOMNAME3L="AS4FLAG" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDD43V" FIELDNAME="ACCESSMODE" DDLANGUAGE="E" POSITION="0005" ROLLNAME="SECKEY_ACCESSMODE" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="SECKEY_ACCESSMODE" ROUTPUTLEN="000000" HEADLEN="15" SCRLEN1="00" SCRLEN2="00" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Access Type for Table Type Secondary Keys" REPTEXT="Access Type" SCRTEXT_L="Access Type" DOMNAME3L="SECKEY_ACCESSMODE" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDD43V" FIELDNAME="KIND" DDLANGUAGE="E" POSITION="0006" ROLLNAME="SECKEY_KIND" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="SECKEY_KIND" ROUTPUTLEN="000000" HEADLEN="15" SCRLEN1="00" SCRLEN2="00" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Definition of Secondary Key" REPTEXT="Key" SCRTEXT_L="Key Definition" DOMNAME3L="SECKEY_KIND" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDD43V" FIELDNAME="KEYDESCRIPTION" DDLANGUAGE="E" POSITION="0007" ROLLNAME="DDTEXT80" ADMINFIELD="0" INTTYPE="C" INTLEN="000160" DOMNAME="TEXT80" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000080" OUTPUTLEN="000080" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Short Description" SCRTEXT_L="Short Description" DOMNAME3L="TEXT80" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TTYP TYPENAME="ZDD07V_TAB" DDLANGUAGE="E" ROWTYPE="DD07V" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Copy of table type DD07V_TAB" TYPELEN="000272" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZSEO_CLASS_NAMES" DDLANGUAGE="E" ROWTYPE="SEOCLASS" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Copy of standard table type SEO_CLASS_NAMES" TYPELEN="000080" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZTT_WB_CLASS_LOCAL" DDLANGUAGE="E" ROWTYPE="ZCL_WB_CLASS_LOCAL" ROWKIND="R" DATATYPE="REF" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table of WB local classes" TYPELEN="000008" CTLENG="000000" CTDECIMALS="000000" REFTYPE="C" OCCURS="00000"/>
 <TTYP TYPENAME="ZTT_WB_INTERFACE_LOCAL" DDLANGUAGE="E" ROWTYPE="ZCL_WB_INTERFACE_LOCAL" ROWKIND="R" DATATYPE="REF" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table of WB local interfaces" TYPELEN="000008" CTLENG="000000" CTDECIMALS="000000" REFTYPE="C" OCCURS="00000"/>
</nugget>
